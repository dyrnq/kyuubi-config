[
  {
    "Property Name": "spark.app.name",
    "Default": "(none)",
    "Meaning": "The name of your application. This will appear in the UI and in log data.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.driver.cores",
    "Default": "1",
    "Meaning": "Number of cores to use for the driver process, only in cluster mode.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.driver.maxResultSize",
    "Default": "1g",
    "Meaning": "Limit of total size of serialized results of all partitions for each Spark action (e.g. collect) in bytes. Should be at least 1M, or 0 for unlimited. Jobs will be aborted if the total size is above this limit. Having a high limit may cause out-of-memory errors in driver (depends on spark.driver.memory and memory overhead of objects in JVM). Setting a proper limit can protect the driver from out-of-memory errors.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.driver.memory",
    "Default": "1g",
    "Meaning": "Amount of memory to use for the driver process, i.e. where SparkContext is initialized, in the same format as JVM memory strings with a size unit suffix (\"k\", \"m\", \"g\" or \"t\") (e.g. 512m, 2g). Note: In client mode, this config must not be set through the SparkConf directly in your application, because the driver JVM has already started at that point. Instead, please set this through the --driver-memory command line option or in your default properties file.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.driver.memoryOverhead",
    "Default": "driverMemory * spark.driver.memoryOverheadFactor, with minimum of 384",
    "Meaning": "Amount of non-heap memory to be allocated per driver process in cluster mode, in MiB unless otherwise specified. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the container size (typically 6-10%). This option is currently supported on YARN, Mesos and Kubernetes. Note: Non-heap memory includes off-heap memory (when spark.memory.offHeap.enabled\u003dtrue) and memory used by other driver processes (e.g. python process that goes with a PySpark driver) and memory used by other non-driver processes running in the same container. The maximum memory size of container to running driver is determined by the sum of spark.driver.memoryOverhead and spark.driver.memory.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.driver.memoryOverheadFactor",
    "Default": "0.10",
    "Meaning": "Fraction of driver memory to be allocated as additional non-heap memory per driver process in cluster mode. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the container size. This value defaults to 0.10 except for Kubernetes non-JVM jobs, which defaults to 0.40. This is done as non-JVM tasks need more non-JVM heap space and such tasks commonly fail with \"Memory Overhead Exceeded\" errors. This preempts this error with a higher default. This value is ignored if spark.driver.memoryOverhead is set directly.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.driver.resource.{resourceName}.amount",
    "Default": "0",
    "Meaning": "Amount of a particular resource type to use on the driver. If this is used, you must also specify the spark.driver.resource.{resourceName}.discoveryScript for the driver to find the resource on startup.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.driver.resource.{resourceName}.discoveryScript",
    "Default": "None",
    "Meaning": "A script for the driver to run to discover a particular resource type. This should write to STDOUT a JSON string in the format of the ResourceInformation class. This has a name and an array of addresses. For a client-submitted driver, discovery script must assign different resource addresses to this driver comparing to other drivers on the same host.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.driver.resource.{resourceName}.vendor",
    "Default": "None",
    "Meaning": "Vendor of the resources to use for the driver. This option is currently only supported on Kubernetes and is actually both the vendor and domain following the Kubernetes device plugin naming convention. (e.g. For GPUs on Kubernetes this config would be set to nvidia.com or amd.com)",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.resources.discoveryPlugin",
    "Default": "org.apache.spark.resource.ResourceDiscoveryScriptPlugin",
    "Meaning": "Comma-separated list of class names implementing org.apache.spark.api.resource.ResourceDiscoveryPlugin to load into the application. This is for advanced users to replace the resource discovery class with a custom implementation. Spark will try each class specified until one of them returns the resource information for that resource. It tries the discovery script last if none of the plugins return information for that resource.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.memory",
    "Default": "1g",
    "Meaning": "Amount of memory to use per executor process, in the same format as JVM memory strings with a size unit suffix (\"k\", \"m\", \"g\" or \"t\") (e.g. 512m, 2g).",
    "Since Version": "0.7.0"
  },
  {
    "Property Name": "spark.executor.pyspark.memory",
    "Default": "Not set",
    "Meaning": "The amount of memory to be allocated to PySpark in each executor, in MiB unless otherwise specified. If set, PySpark memory for an executor will be limited to this amount. If not set, Spark will not limit Python\u0027s memory use and it is up to the application to avoid exceeding the overhead memory space shared with other non-JVM processes. When PySpark is run in YARN or Kubernetes, this memory is added to executor resource requests. Note: This feature is dependent on Python\u0027s `resource` module; therefore, the behaviors and limitations are inherited. For instance, Windows does not support resource limiting and actual resource is not limited on MacOS.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.executor.memoryOverhead",
    "Default": "executorMemory * spark.executor.memoryOverheadFactor, with minimum of 384",
    "Meaning": "Amount of additional memory to be allocated per executor process, in MiB unless otherwise specified. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the executor size (typically 6-10%). This option is currently supported on YARN and Kubernetes. Note: Additional memory includes PySpark executor memory (when spark.executor.pyspark.memory is not configured) and memory used by other non-executor processes running in the same container. The maximum memory size of container to running executor is determined by the sum of spark.executor.memoryOverhead, spark.executor.memory, spark.memory.offHeap.size and spark.executor.pyspark.memory.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.executor.memoryOverheadFactor",
    "Default": "0.10",
    "Meaning": "Fraction of executor memory to be allocated as additional non-heap memory per executor process. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the container size. This value defaults to 0.10 except for Kubernetes non-JVM jobs, which defaults to 0.40. This is done as non-JVM tasks need more non-JVM heap space and such tasks commonly fail with \"Memory Overhead Exceeded\" errors. This preempts this error with a higher default. This value is ignored if spark.executor.memoryOverhead is set directly.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.executor.resource.{resourceName}.amount",
    "Default": "0",
    "Meaning": "Amount of a particular resource type to use per executor process. If this is used, you must also specify the spark.executor.resource.{resourceName}.discoveryScript for the executor to find the resource on startup.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.resource.{resourceName}.discoveryScript",
    "Default": "None",
    "Meaning": "A script for the executor to run to discover a particular resource type. This should write to STDOUT a JSON string in the format of the ResourceInformation class. This has a name and an array of addresses.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.resource.{resourceName}.vendor",
    "Default": "None",
    "Meaning": "Vendor of the resources to use for the executors. This option is currently only supported on Kubernetes and is actually both the vendor and domain following the Kubernetes device plugin naming convention. (e.g. For GPUs on Kubernetes this config would be set to nvidia.com or amd.com)",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.extraListeners",
    "Default": "(none)",
    "Meaning": "A comma-separated list of classes that implement SparkListener; when initializing SparkContext, instances of these classes will be created and registered with Spark\u0027s listener bus. If a class has a single-argument constructor that accepts a SparkConf, that constructor will be called; otherwise, a zero-argument constructor will be called. If no valid constructor can be found, the SparkContext creation will fail with an exception.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.local.dir",
    "Default": "/tmp",
    "Meaning": "Directory to use for \"scratch\" space in Spark, including map output files and RDDs that get stored on disk. This should be on a fast, local disk in your system. It can also be a comma-separated list of multiple directories on different disks. Note: This will be overridden by SPARK_LOCAL_DIRS (Standalone), MESOS_SANDBOX (Mesos) or LOCAL_DIRS (YARN) environment variables set by the cluster manager.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.logConf",
    "Default": "false",
    "Meaning": "Logs the effective SparkConf as INFO when a SparkContext is started.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.master",
    "Default": "(none)",
    "Meaning": "The cluster manager to connect to. See the list of allowed master URL\u0027s.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.submit.deployMode",
    "Default": "client",
    "Meaning": "The deploy mode of Spark driver program, either \"client\" or \"cluster\", Which means to launch driver program locally (\"client\") or remotely (\"cluster\") on one of the nodes inside the cluster.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.log.callerContext",
    "Default": "(none)",
    "Meaning": "Application information that will be written into Yarn RM log/HDFS audit log when running on Yarn/HDFS. Its length depends on the Hadoop configuration hadoop.caller.context.max.size. It should be concise, and typically can have up to 50 characters.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.log.level",
    "Default": "(none)",
    "Meaning": "When set, overrides any user-defined log settings as if calling SparkContext.setLogLevel() at Spark startup. Valid log levels include: \"ALL\", \"DEBUG\", \"ERROR\", \"FATAL\", \"INFO\", \"OFF\", \"TRACE\", \"WARN\".",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.driver.supervise",
    "Default": "false",
    "Meaning": "If true, restarts the driver automatically if it fails with a non-zero exit status. Only has effect in Spark standalone mode or Mesos cluster deploy mode.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.driver.log.dfsDir",
    "Default": "(none)",
    "Meaning": "Base directory in which Spark driver logs are synced, if spark.driver.log.persistToDfs.enabled is true. Within this base directory, each application logs the driver logs to an application specific file. Users may want to set this to a unified location like an HDFS directory so driver log files can be persisted for later usage. This directory should allow any Spark user to read/write files and the Spark History Server user to delete files. Additionally, older logs from this directory are cleaned by the Spark History Server if spark.history.fs.driverlog.cleaner.enabled is true and, if they are older than max age configured by setting spark.history.fs.driverlog.cleaner.maxAge.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.driver.log.persistToDfs.enabled",
    "Default": "false",
    "Meaning": "If true, spark application running in client mode will write driver logs to a persistent storage, configured in spark.driver.log.dfsDir. If spark.driver.log.dfsDir is not configured, driver logs will not be persisted. Additionally, enable the cleaner by setting spark.history.fs.driverlog.cleaner.enabled to true in Spark History Server.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.driver.log.layout",
    "Default": "%d{yy/MM/dd HH:mm:ss.SSS} %t %p %c{1}: %m%n%ex",
    "Meaning": "The layout for the driver logs that are synced to spark.driver.log.dfsDir. If this is not configured, it uses the layout for the first appender defined in log4j2.properties. If that is also not configured, driver logs use the default layout.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.driver.log.allowErasureCoding",
    "Default": "false",
    "Meaning": "Whether to allow driver logs to use erasure coding. On HDFS, erasure coded files will not update as quickly as regular replicated files, so they make take longer to reflect changes written by the application. Note that even if this is true, Spark will still not force the file to use erasure coding, it will simply use file system defaults.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.decommission.enabled",
    "Default": "false",
    "Meaning": "When decommission enabled, Spark will try its best to shut down the executor gracefully. Spark will try to migrate all the RDD blocks (controlled by spark.storage.decommission.rddBlocks.enabled) and shuffle blocks (controlled by spark.storage.decommission.shuffleBlocks.enabled) from the decommissioning executor to a remote executor when spark.storage.decommission.enabled is enabled. With decommission enabled, Spark will also decommission an executor instead of killing when spark.dynamicAllocation.enabled enabled.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.executor.decommission.killInterval",
    "Default": "(none)",
    "Meaning": "Duration after which a decommissioned executor will be killed forcefully by an outside (e.g. non-spark) service.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.executor.decommission.forceKillTimeout",
    "Default": "(none)",
    "Meaning": "Duration after which a Spark will force a decommissioning executor to exit. This should be set to a high value in most situations as low values will prevent block migrations from having enough time to complete.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.executor.decommission.signal",
    "Default": "PWR",
    "Meaning": "The signal that used to trigger the executor to start decommission.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.executor.maxNumFailures",
    "Default": "numExecutors * 2, with minimum of 3",
    "Meaning": "The maximum number of executor failures before failing the application. This configuration only takes effect on YARN, or Kubernetes when `spark.kubernetes.allocation.pods.allocator` is set to \u0027direct\u0027.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.executor.failuresValidityInterval",
    "Default": "(none)",
    "Meaning": "Interval after which executor failures will be considered independent and not accumulate towards the attempt count. This configuration only takes effect on YARN, or Kubernetes when `spark.kubernetes.allocation.pods.allocator` is set to \u0027direct\u0027.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.driver.extraClassPath",
    "Default": "(none)",
    "Meaning": "Extra classpath entries to prepend to the classpath of the driver. Note: In client mode, this config must not be set through the SparkConf directly in your application, because the driver JVM has already started at that point. Instead, please set this through the --driver-class-path command line option or in your default properties file.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.driver.defaultJavaOptions",
    "Default": "(none)",
    "Meaning": "A string of default JVM options to prepend to spark.driver.extraJavaOptions. This is intended to be set by administrators. For instance, GC settings or other logging. Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap size settings can be set with spark.driver.memory in the cluster mode and through the --driver-memory command line option in the client mode. Note: In client mode, this config must not be set through the SparkConf directly in your application, because the driver JVM has already started at that point. Instead, please set this through the --driver-java-options command line option or in your default properties file.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.driver.extraJavaOptions",
    "Default": "(none)",
    "Meaning": "A string of extra JVM options to pass to the driver. This is intended to be set by users. For instance, GC settings or other logging. Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap size settings can be set with spark.driver.memory in the cluster mode and through the --driver-memory command line option in the client mode. Note: In client mode, this config must not be set through the SparkConf directly in your application, because the driver JVM has already started at that point. Instead, please set this through the --driver-java-options command line option or in your default properties file. spark.driver.defaultJavaOptions will be prepended to this configuration.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.driver.extraLibraryPath",
    "Default": "(none)",
    "Meaning": "Set a special library path to use when launching the driver JVM. Note: In client mode, this config must not be set through the SparkConf directly in your application, because the driver JVM has already started at that point. Instead, please set this through the --driver-library-path command line option or in your default properties file.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.driver.userClassPathFirst",
    "Default": "false",
    "Meaning": "(Experimental) Whether to give user-added jars precedence over Spark\u0027s own jars when loading classes in the driver. This feature can be used to mitigate conflicts between Spark\u0027s dependencies and user dependencies. It is currently an experimental feature. This is used in cluster mode only.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.executor.extraClassPath",
    "Default": "(none)",
    "Meaning": "Extra classpath entries to prepend to the classpath of executors. This exists primarily for backwards-compatibility with older versions of Spark. Users typically should not need to set this option.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.executor.defaultJavaOptions",
    "Default": "(none)",
    "Meaning": "A string of default JVM options to prepend to spark.executor.extraJavaOptions. This is intended to be set by administrators. For instance, GC settings or other logging. Note that it is illegal to set Spark properties or maximum heap size (-Xmx) settings with this option. Spark properties should be set using a SparkConf object or the spark-defaults.conf file used with the spark-submit script. Maximum heap size settings can be set with spark.executor.memory. The following symbols, if present will be interpolated: will be replaced by application ID and will be replaced by executor ID. For example, to enable verbose gc logging to a file named for the executor ID of the app in /tmp, pass a \u0027value\u0027 of: -verbose:gc -Xloggc:/tmp/-.gc",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.extraJavaOptions",
    "Default": "(none)",
    "Meaning": "A string of extra JVM options to pass to executors. This is intended to be set by users. For instance, GC settings or other logging. Note that it is illegal to set Spark properties or maximum heap size (-Xmx) settings with this option. Spark properties should be set using a SparkConf object or the spark-defaults.conf file used with the spark-submit script. Maximum heap size settings can be set with spark.executor.memory. The following symbols, if present will be interpolated: will be replaced by application ID and will be replaced by executor ID. For example, to enable verbose gc logging to a file named for the executor ID of the app in /tmp, pass a \u0027value\u0027 of: -verbose:gc -Xloggc:/tmp/-.gc spark.executor.defaultJavaOptions will be prepended to this configuration.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.executor.extraLibraryPath",
    "Default": "(none)",
    "Meaning": "Set a special library path to use when launching executor JVM\u0027s.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.executor.logs.rolling.maxRetainedFiles",
    "Default": "-1",
    "Meaning": "Sets the number of latest rolling log files that are going to be retained by the system. Older log files will be deleted. Disabled by default.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.executor.logs.rolling.enableCompression",
    "Default": "false",
    "Meaning": "Enable executor log compression. If it is enabled, the rolled executor logs will be compressed. Disabled by default.",
    "Since Version": "2.0.2"
  },
  {
    "Property Name": "spark.executor.logs.rolling.maxSize",
    "Default": "1024 * 1024",
    "Meaning": "Set the max size of the file in bytes by which the executor logs will be rolled over. Rolling is disabled by default. See spark.executor.logs.rolling.maxRetainedFiles for automatic cleaning of old logs.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.executor.logs.rolling.strategy",
    "Default": "(none)",
    "Meaning": "Set the strategy of rolling of executor logs. By default it is disabled. It can be set to \"time\" (time-based rolling) or \"size\" (size-based rolling). For \"time\", use spark.executor.logs.rolling.time.interval to set the rolling interval. For \"size\", use spark.executor.logs.rolling.maxSize to set the maximum file size for rolling.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.executor.logs.rolling.time.interval",
    "Default": "daily",
    "Meaning": "Set the time interval by which the executor logs will be rolled over. Rolling is disabled by default. Valid values are daily, hourly, minutely or any interval in seconds. See spark.executor.logs.rolling.maxRetainedFiles for automatic cleaning of old logs.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.executor.userClassPathFirst",
    "Default": "false",
    "Meaning": "(Experimental) Same functionality as spark.driver.userClassPathFirst, but applied to executor instances.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.executorEnv.[EnvironmentVariableName]",
    "Default": "(none)",
    "Meaning": "Add the environment variable specified by EnvironmentVariableName to the Executor process. The user can specify multiple of these to set multiple environment variables.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.redaction.regex",
    "Default": "(?i)secret|password|token|access[.]key",
    "Meaning": "Regex to decide which Spark configuration properties and environment variables in driver and executor environments contain sensitive information. When this regex matches a property key or value, the value is redacted from the environment UI and various logs like YARN and event logs.",
    "Since Version": "2.1.2"
  },
  {
    "Property Name": "spark.redaction.string.regex",
    "Default": "(none)",
    "Meaning": "Regex to decide which parts of strings produced by Spark contain sensitive information. When this regex matches a string part, that string part is replaced by a dummy value. This is currently used to redact the output of SQL explain commands.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.python.profile",
    "Default": "false",
    "Meaning": "Enable profiling in Python worker, the profile result will show up by sc.show_profiles(), or it will be displayed before the driver exits. It also can be dumped into disk by sc.dump_profiles(path). If some of the profile results had been displayed manually, they will not be displayed automatically before driver exiting. By default the pyspark.profiler.BasicProfiler will be used, but this can be overridden by passing a profiler class in as a parameter to the SparkContext constructor.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.python.profile.dump",
    "Default": "(none)",
    "Meaning": "The directory which is used to dump the profile result before driver exiting. The results will be dumped as separated file for each RDD. They can be loaded by pstats.Stats(). If this is specified, the profile result will not be displayed automatically.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.python.worker.memory",
    "Default": "512m",
    "Meaning": "Amount of memory to use per python worker process during aggregation, in the same format as JVM memory strings with a size unit suffix (\"k\", \"m\", \"g\" or \"t\") (e.g. 512m, 2g). If the memory used during aggregation goes above this amount, it will spill the data into disks.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.python.worker.reuse",
    "Default": "true",
    "Meaning": "Reuse Python worker or not. If yes, it will use a fixed number of Python workers, does not need to fork() a Python process for every task. It will be very useful if there is a large broadcast, then the broadcast will not need to be transferred from JVM to Python worker for every task.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.files",
    "Default": "",
    "Meaning": "Comma-separated list of files to be placed in the working directory of each executor. Globs are allowed.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.submit.pyFiles",
    "Default": "",
    "Meaning": "Comma-separated list of .zip, .egg, or .py files to place on the PYTHONPATH for Python apps. Globs are allowed.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.jars",
    "Default": "",
    "Meaning": "Comma-separated list of jars to include on the driver and executor classpaths. Globs are allowed.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.jars.packages",
    "Default": "",
    "Meaning": "Comma-separated list of Maven coordinates of jars to include on the driver and executor classpaths. The coordinates should be groupId:artifactId:version. If spark.jars.ivySettings is given artifacts will be resolved according to the configuration in the file, otherwise artifacts will be searched for in the local maven repo, then maven central and finally any additional remote repositories given by the command-line option --repositories. For more details, see Advanced Dependency Management.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.jars.excludes",
    "Default": "",
    "Meaning": "Comma-separated list of groupId:artifactId, to exclude while resolving the dependencies provided in spark.jars.packages to avoid dependency conflicts.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.jars.ivy",
    "Default": "",
    "Meaning": "Path to specify the Ivy user directory, used for the local Ivy cache and package files from spark.jars.packages. This will override the Ivy property ivy.default.ivy.user.dir which defaults to ~/.ivy2.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.jars.ivySettings",
    "Default": "",
    "Meaning": "Path to an Ivy settings file to customize resolution of jars specified using spark.jars.packages instead of the built-in defaults, such as maven central. Additional repositories given by the command-line option --repositories or spark.jars.repositories will also be included. Useful for allowing Spark to resolve artifacts from behind a firewall e.g. via an in-house artifact server like Artifactory. Details on the settings file format can be found at Settings Files. Only paths with file:// scheme are supported. Paths without a scheme are assumed to have a file:// scheme. When running in YARN cluster mode, this file will also be localized to the remote driver for dependency resolution within SparkContext#addJar",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.jars.repositories",
    "Default": "",
    "Meaning": "Comma-separated list of additional remote repositories to search for the maven coordinates given with --packages or spark.jars.packages.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.archives",
    "Default": "",
    "Meaning": "Comma-separated list of archives to be extracted into the working directory of each executor. .jar, .tar.gz, .tgz and .zip are supported. You can specify the directory name to unpack via adding # after the file name to unpack, for example, file.zip#directory. This configuration is experimental.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.pyspark.driver.python",
    "Default": "",
    "Meaning": "Python binary executable to use for PySpark in driver. (default is spark.pyspark.python)",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.pyspark.python",
    "Default": "",
    "Meaning": "Python binary executable to use for PySpark in both driver and executors.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.reducer.maxSizeInFlight",
    "Default": "48m",
    "Meaning": "Maximum size of map outputs to fetch simultaneously from each reduce task, in MiB unless otherwise specified. Since each output requires us to create a buffer to receive it, this represents a fixed memory overhead per reduce task, so keep it small unless you have a large amount of memory.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.reducer.maxReqsInFlight",
    "Default": "Int.MaxValue",
    "Meaning": "This configuration limits the number of remote requests to fetch blocks at any given point. When the number of hosts in the cluster increase, it might lead to very large number of inbound connections to one or more nodes, causing the workers to fail under load. By allowing it to limit the number of fetch requests, this scenario can be mitigated.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.reducer.maxBlocksInFlightPerAddress",
    "Default": "Int.MaxValue",
    "Meaning": "This configuration limits the number of remote blocks being fetched per reduce task from a given host port. When a large number of blocks are being requested from a given address in a single fetch or simultaneously, this could crash the serving executor or Node Manager. This is especially useful to reduce the load on the Node Manager when external shuffle is enabled. You can mitigate this issue by setting it to a lower value.",
    "Since Version": "2.2.1"
  },
  {
    "Property Name": "spark.shuffle.compress",
    "Default": "true",
    "Meaning": "Whether to compress map output files. Generally a good idea. Compression will use spark.io.compression.codec.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.shuffle.file.buffer",
    "Default": "32k",
    "Meaning": "Size of the in-memory buffer for each shuffle file output stream, in KiB unless otherwise specified. These buffers reduce the number of disk seeks and system calls made in creating intermediate shuffle files.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.shuffle.unsafe.file.output.buffer",
    "Default": "32k",
    "Meaning": "The file system for this buffer size after each partition is written in unsafe shuffle writer. In KiB unless otherwise specified.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.shuffle.spill.diskWriteBufferSize",
    "Default": "1024 * 1024",
    "Meaning": "The buffer size, in bytes, to use when writing the sorted records to an on-disk file.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.shuffle.io.maxRetries",
    "Default": "3",
    "Meaning": "(Netty only) Fetches that fail due to IO-related exceptions are automatically retried if this is set to a non-zero value. This retry logic helps stabilize large shuffles in the face of long GC pauses or transient network connectivity issues.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.shuffle.io.numConnectionsPerPeer",
    "Default": "1",
    "Meaning": "(Netty only) Connections between hosts are reused in order to reduce connection buildup for large clusters. For clusters with many hard disks and few hosts, this may result in insufficient concurrency to saturate all disks, and so users may consider increasing this value.",
    "Since Version": "1.2.1"
  },
  {
    "Property Name": "spark.shuffle.io.preferDirectBufs",
    "Default": "true",
    "Meaning": "(Netty only) Off-heap buffers are used to reduce garbage collection during shuffle and cache block transfer. For environments where off-heap memory is tightly limited, users may wish to turn this off to force all allocations from Netty to be on-heap.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.shuffle.io.retryWait",
    "Default": "5s",
    "Meaning": "(Netty only) How long to wait between retries of fetches. The maximum delay caused by retrying is 15 seconds by default, calculated as maxRetries * retryWait.",
    "Since Version": "1.2.1"
  },
  {
    "Property Name": "spark.shuffle.io.backLog",
    "Default": "-1",
    "Meaning": "Length of the accept queue for the shuffle service. For large applications, this value may need to be increased, so that incoming connections are not dropped if the service cannot keep up with a large number of connections arriving in a short period of time. This needs to be configured wherever the shuffle service itself is running, which may be outside of the application (see spark.shuffle.service.enabled option below). If set below 1, will fallback to OS default defined by Netty\u0027s io.netty.util.NetUtil#SOMAXCONN.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.shuffle.io.connectionTimeout",
    "Default": "value of spark.network.timeout",
    "Meaning": "Timeout for the established connections between shuffle servers and clients to be marked as idled and closed if there are still outstanding fetch requests but no traffic no the channel for at least `connectionTimeout`.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.shuffle.io.connectionCreationTimeout",
    "Default": "value of spark.shuffle.io.connectionTimeout",
    "Meaning": "Timeout for establishing a connection between the shuffle servers and clients.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.service.enabled",
    "Default": "false",
    "Meaning": "Enables the external shuffle service. This service preserves the shuffle files written by executors e.g. so that executors can be safely removed, or so that shuffle fetches can continue in the event of executor failure. The external shuffle service must be set up in order to enable it. See dynamic allocation configuration and setup documentation for more information.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.shuffle.service.port",
    "Default": "7337",
    "Meaning": "Port on which the external shuffle service will run.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.shuffle.service.name",
    "Default": "spark_shuffle",
    "Meaning": "The configured name of the Spark shuffle service the client should communicate with. This must match the name used to configure the Shuffle within the YARN NodeManager configuration (yarn.nodemanager.aux-services). Only takes effect when spark.shuffle.service.enabled is set to true.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.service.index.cache.size",
    "Default": "100m",
    "Meaning": "Cache entries limited to the specified memory footprint, in bytes unless otherwise specified.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.shuffle.service.removeShuffle",
    "Default": "false",
    "Meaning": "Whether to use the ExternalShuffleService for deleting shuffle blocks for deallocated executors when the shuffle is no longer needed. Without this enabled, shuffle data on executors that are deallocated will remain on disk until the application ends.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.shuffle.maxChunksBeingTransferred",
    "Default": "Long.MAX_VALUE",
    "Meaning": "The max number of chunks allowed to be transferred at the same time on shuffle service. Note that new incoming connections will be closed when the max number is hit. The client will retry according to the shuffle retry configs (see spark.shuffle.io.maxRetries and spark.shuffle.io.retryWait), if those limits are reached the task will fail with fetch failure.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.shuffle.sort.bypassMergeThreshold",
    "Default": "200",
    "Meaning": "(Advanced) In the sort-based shuffle manager, avoid merge-sorting data if there is no map-side aggregation and there are at most this many reduce partitions.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.shuffle.sort.io.plugin.class",
    "Default": "org.apache.spark.shuffle.sort.io.LocalDiskShuffleDataIO",
    "Meaning": "Name of the class to use for shuffle IO.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.shuffle.spill.compress",
    "Default": "true",
    "Meaning": "Whether to compress data spilled during shuffles. Compression will use spark.io.compression.codec.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.shuffle.accurateBlockThreshold",
    "Default": "100 * 1024 * 1024",
    "Meaning": "Threshold in bytes above which the size of shuffle blocks in HighlyCompressedMapStatus is accurately recorded. This helps to prevent OOM by avoiding underestimating shuffle block size when fetch shuffle blocks.",
    "Since Version": "2.2.1"
  },
  {
    "Property Name": "spark.shuffle.registration.timeout",
    "Default": "5000",
    "Meaning": "Timeout in milliseconds for registration to the external shuffle service.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.shuffle.registration.maxAttempts",
    "Default": "3",
    "Meaning": "When we fail to register to the external shuffle service, we will retry for maxAttempts times.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.shuffle.reduceLocality.enabled",
    "Default": "true",
    "Meaning": "Whether to compute locality preferences for reduce tasks.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.shuffle.mapOutput.minSizeForBroadcast",
    "Default": "512k",
    "Meaning": "The size at which we use Broadcast to send the map output statuses to the executors.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.shuffle.detectCorrupt",
    "Default": "true",
    "Meaning": "Whether to detect any corruption in fetched blocks.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.shuffle.detectCorrupt.useExtraMemory",
    "Default": "false",
    "Meaning": "If enabled, part of a compressed/encrypted stream will be de-compressed/de-crypted by using extra memory to detect early corruption. Any IOException thrown will cause the task to be retried once and if it fails again with same exception, then FetchFailedException will be thrown to retry previous stage.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.shuffle.useOldFetchProtocol",
    "Default": "false",
    "Meaning": "Whether to use the old protocol while doing the shuffle block fetching. It is only enabled while we need the compatibility in the scenario of new Spark version job fetching shuffle blocks from old version external shuffle service.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.shuffle.readHostLocalDisk",
    "Default": "true",
    "Meaning": "If enabled (and spark.shuffle.useOldFetchProtocol is disabled, shuffle blocks requested from those block managers which are running on the same host are read from the disk directly instead of being fetched as remote blocks over the network.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.files.io.connectionTimeout",
    "Default": "value of spark.network.timeout",
    "Meaning": "Timeout for the established connections for fetching files in Spark RPC environments to be marked as idled and closed if there are still outstanding files being downloaded but no traffic no the channel for at least `connectionTimeout`.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.files.io.connectionCreationTimeout",
    "Default": "value of spark.files.io.connectionTimeout",
    "Meaning": "Timeout for establishing a connection for fetching files in Spark RPC environments.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.checksum.enabled",
    "Default": "true",
    "Meaning": "Whether to calculate the checksum of shuffle data. If enabled, Spark will calculate the checksum values for each partition data within the map output file and store the values in a checksum file on the disk. When there\u0027s shuffle data corruption detected, Spark will try to diagnose the cause (e.g., network issue, disk issue, etc.) of the corruption by using the checksum file.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.checksum.algorithm",
    "Default": "ADLER32",
    "Meaning": "The algorithm is used to calculate the shuffle checksum. Currently, it only supports built-in algorithms of JDK, e.g., ADLER32, CRC32.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.service.fetch.rdd.enabled",
    "Default": "false",
    "Meaning": "Whether to use the ExternalShuffleService for fetching disk persisted RDD blocks. In case of dynamic allocation if this feature is enabled executors having only disk persisted blocks are considered idle after spark.dynamicAllocation.executorIdleTimeout and will be released accordingly.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.shuffle.service.db.enabled",
    "Default": "true",
    "Meaning": "Whether to use db in ExternalShuffleService. Note that this only affects standalone mode.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.shuffle.service.db.backend",
    "Default": "LEVELDB",
    "Meaning": "Specifies a disk-based store used in shuffle service local db. Setting as LEVELDB or ROCKSDB.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.eventLog.logBlockUpdates.enabled",
    "Default": "false",
    "Meaning": "Whether to log events for every block update, if spark.eventLog.enabled is true. *Warning*: This will increase the size of the event log considerably.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.eventLog.longForm.enabled",
    "Default": "false",
    "Meaning": "If true, use the long form of call sites in the event log. Otherwise use the short form.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.eventLog.compress",
    "Default": "false",
    "Meaning": "Whether to compress logged events, if spark.eventLog.enabled is true.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.eventLog.compression.codec",
    "Default": "zstd",
    "Meaning": "The codec to compress logged events. By default, Spark provides four codecs: lz4, lzf, snappy, and zstd. You can also use fully qualified class names to specify the codec, e.g. org.apache.spark.io.LZ4CompressionCodec, org.apache.spark.io.LZFCompressionCodec, org.apache.spark.io.SnappyCompressionCodec, and org.apache.spark.io.ZStdCompressionCodec.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.eventLog.erasureCoding.enabled",
    "Default": "false",
    "Meaning": "Whether to allow event logs to use erasure coding, or turn erasure coding off, regardless of filesystem defaults. On HDFS, erasure coded files will not update as quickly as regular replicated files, so the application updates will take longer to appear in the History Server. Note that even if this is true, Spark will still not force the file to use erasure coding, it will simply use filesystem defaults.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.eventLog.dir",
    "Default": "file:///tmp/spark-events",
    "Meaning": "Base directory in which Spark events are logged, if spark.eventLog.enabled is true. Within this base directory, Spark creates a sub-directory for each application, and logs the events specific to the application in this directory. Users may want to set this to a unified location like an HDFS directory so history files can be read by the history server.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.eventLog.enabled",
    "Default": "false",
    "Meaning": "Whether to log Spark events, useful for reconstructing the Web UI after the application has finished.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.eventLog.overwrite",
    "Default": "false",
    "Meaning": "Whether to overwrite any existing files.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.eventLog.buffer.kb",
    "Default": "100k",
    "Meaning": "Buffer size to use when writing to output streams, in KiB unless otherwise specified.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.eventLog.rolling.enabled",
    "Default": "false",
    "Meaning": "Whether rolling over event log files is enabled. If set to true, it cuts down each event log file to the configured size.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.eventLog.rolling.maxFileSize",
    "Default": "128m",
    "Meaning": "When spark.eventLog.rolling.enabled\u003dtrue, specifies the max size of event log file before it\u0027s rolled over.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.ui.dagGraph.retainedRootRDDs",
    "Default": "Int.MaxValue",
    "Meaning": "How many DAG graph nodes the Spark UI and status APIs remember before garbage collecting.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.ui.enabled",
    "Default": "true",
    "Meaning": "Whether to run the web UI for the Spark application.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.ui.store.path",
    "Default": "None",
    "Meaning": "Local directory where to cache application information for live UI. By default this is not set, meaning all application information will be kept in memory.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.ui.killEnabled",
    "Default": "true",
    "Meaning": "Allows jobs and stages to be killed from the web UI.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.ui.liveUpdate.period",
    "Default": "100ms",
    "Meaning": "How often to update live entities. -1 means \"never update\" when replaying applications, meaning only the last write will happen. For live applications, this avoids a few operations that we can live without when rapidly processing incoming task events.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.ui.liveUpdate.minFlushPeriod",
    "Default": "1s",
    "Meaning": "Minimum time elapsed before stale UI data is flushed. This avoids UI staleness when incoming task events are not fired frequently.",
    "Since Version": "2.4.2"
  },
  {
    "Property Name": "spark.ui.port",
    "Default": "4040",
    "Meaning": "Port for your application\u0027s dashboard, which shows memory and workload data.",
    "Since Version": "0.7.0"
  },
  {
    "Property Name": "spark.ui.retainedJobs",
    "Default": "1000",
    "Meaning": "How many jobs the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.ui.retainedStages",
    "Default": "1000",
    "Meaning": "How many stages the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.ui.retainedTasks",
    "Default": "100000",
    "Meaning": "How many tasks in one stage the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.",
    "Since Version": "2.0.1"
  },
  {
    "Property Name": "spark.ui.reverseProxy",
    "Default": "false",
    "Meaning": "Enable running Spark Master as reverse proxy for worker and application UIs. In this mode, Spark master will reverse proxy the worker and application UIs to enable access without requiring direct access to their hosts. Use it with caution, as worker and application UI will not be accessible directly, you will only be able to access them through spark master/proxy public URL. This setting affects all the workers and application UIs running in the cluster and must be set on all the workers, drivers and masters.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.ui.reverseProxyUrl",
    "Default": "",
    "Meaning": "If the Spark UI should be served through another front-end reverse proxy, this is the URL for accessing the Spark master UI through that reverse proxy. This is useful when running proxy for authentication e.g. an OAuth proxy. The URL may contain a path prefix, like http://mydomain.com/path/to/spark/, allowing you to serve the UI for multiple Spark clusters and other web applications through the same virtual host and port. Normally, this should be an absolute URL including scheme (http/https), host and port. It is possible to specify a relative URL starting with \"/\" here. In this case, all URLs generated by the Spark UI and Spark REST APIs will be server-relative links -- this will still work, as the entire Spark UI is served through the same host and port. The setting affects link generation in the Spark UI, but the front-end reverse proxy is responsible for stripping a path prefix before forwarding the request, rewriting redirects which point directly to the Spark master, redirecting access from http://mydomain.com/path/to/spark to http://mydomain.com/path/to/spark/ (trailing slash after path prefix); otherwise relative links on the master page do not work correctly. This setting affects all the workers and application UIs running in the cluster and must be set identically on all the workers, drivers and masters. In is only effective when spark.ui.reverseProxy is turned on. This setting is not needed when the Spark master web UI is directly reachable. Note that the value of the setting can\u0027t contain the keyword `proxy` or `history` after split by \"/\". Spark UI relies on both keywords for getting REST API endpoints from URIs.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.ui.proxyRedirectUri",
    "Default": "",
    "Meaning": "Where to address redirects when Spark is running behind a proxy. This will make Spark modify redirect responses so they point to the proxy server, instead of the Spark UI\u0027s own address. This should be only the address of the server, without any prefix paths for the application; the prefix should be set either by the proxy server itself (by adding the X-Forwarded-Context request header), or by setting the proxy base in the Spark app\u0027s configuration.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.ui.showConsoleProgress",
    "Default": "false",
    "Meaning": "Show the progress bar in the console. The progress bar shows the progress of stages that run for longer than 500ms. If multiple stages run at the same time, multiple progress bars will be displayed on the same line. Note: In shell environment, the default value of spark.ui.showConsoleProgress is true.",
    "Since Version": "1.2.1"
  },
  {
    "Property Name": "spark.ui.custom.executor.log.url",
    "Default": "(none)",
    "Meaning": "Specifies custom spark executor log URL for supporting external log service instead of using cluster managers\u0027 application log URLs in Spark UI. Spark will support some path variables via patterns which can vary on cluster manager. Please check the documentation for your cluster manager to see which patterns are supported, if any. Please note that this configuration also replaces original log urls in event log, which will be also effective when accessing the application on history server. The new log urls must be permanent, otherwise you might have dead link for executor log urls. For now, only YARN and K8s cluster manager supports this configuration",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.worker.ui.retainedExecutors",
    "Default": "1000",
    "Meaning": "How many finished executors the Spark UI and status APIs remember before garbage collecting.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.worker.ui.retainedDrivers",
    "Default": "1000",
    "Meaning": "How many finished drivers the Spark UI and status APIs remember before garbage collecting.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.ui.retainedExecutions",
    "Default": "1000",
    "Meaning": "How many finished executions the Spark UI and status APIs remember before garbage collecting.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.streaming.ui.retainedBatches",
    "Default": "1000",
    "Meaning": "How many finished batches the Spark UI and status APIs remember before garbage collecting.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.ui.retainedDeadExecutors",
    "Default": "100",
    "Meaning": "How many dead executors the Spark UI and status APIs remember before garbage collecting.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.ui.filters",
    "Default": "None",
    "Meaning": "Comma separated list of filter class names to apply to the Spark Web UI. The filter should be a standard javax servlet Filter. Filter parameters can also be specified in the configuration, by setting config entries of the form spark.\u003cclass name of filter\u003e.param.\u003cparam name\u003e\u003d\u003cvalue\u003e For example: spark.ui.filters\u003dcom.test.filter1 spark.com.test.filter1.param.name1\u003dfoo spark.com.test.filter1.param.name2\u003dbar",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.ui.requestHeaderSize",
    "Default": "8k",
    "Meaning": "The maximum allowed size for a HTTP request header, in bytes unless otherwise specified. This setting applies for the Spark History Server too.",
    "Since Version": "2.2.3"
  },
  {
    "Property Name": "spark.ui.timelineEnabled",
    "Default": "true",
    "Meaning": "Whether to display event timeline data on UI pages.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.ui.timeline.executors.maximum",
    "Default": "250",
    "Meaning": "The maximum number of executors shown in the event timeline.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.ui.timeline.jobs.maximum",
    "Default": "500",
    "Meaning": "The maximum number of jobs shown in the event timeline.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.ui.timeline.stages.maximum",
    "Default": "500",
    "Meaning": "The maximum number of stages shown in the event timeline.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.ui.timeline.tasks.maximum",
    "Default": "1000",
    "Meaning": "The maximum number of tasks shown in the event timeline.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.appStatusStore.diskStoreDir",
    "Default": "None",
    "Meaning": "Local directory where to store diagnostic information of SQL executions. This configuration is only for live UI.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.broadcast.compress",
    "Default": "true",
    "Meaning": "Whether to compress broadcast variables before sending them. Generally a good idea. Compression will use spark.io.compression.codec.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.checkpoint.compress",
    "Default": "false",
    "Meaning": "Whether to compress RDD checkpoints. Generally a good idea. Compression will use spark.io.compression.codec.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.io.compression.codec",
    "Default": "lz4",
    "Meaning": "The codec used to compress internal data such as RDD partitions, event log, broadcast variables and shuffle outputs. By default, Spark provides four codecs: lz4, lzf, snappy, and zstd. You can also use fully qualified class names to specify the codec, e.g. org.apache.spark.io.LZ4CompressionCodec, org.apache.spark.io.LZFCompressionCodec, org.apache.spark.io.SnappyCompressionCodec, and org.apache.spark.io.ZStdCompressionCodec.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.io.compression.lz4.blockSize",
    "Default": "32k",
    "Meaning": "Block size used in LZ4 compression, in the case when LZ4 compression codec is used. Lowering this block size will also lower shuffle memory usage when LZ4 is used. Default unit is bytes, unless otherwise specified. This configuration only applies to `spark.io.compression.codec`.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.io.compression.snappy.blockSize",
    "Default": "32k",
    "Meaning": "Block size in Snappy compression, in the case when Snappy compression codec is used. Lowering this block size will also lower shuffle memory usage when Snappy is used. Default unit is bytes, unless otherwise specified. This configuration only applies to `spark.io.compression.codec`.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.io.compression.zstd.level",
    "Default": "1",
    "Meaning": "Compression level for Zstd compression codec. Increasing the compression level will result in better compression at the expense of more CPU and memory. This configuration only applies to `spark.io.compression.codec`.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.io.compression.zstd.bufferSize",
    "Default": "32k",
    "Meaning": "Buffer size in bytes used in Zstd compression, in the case when Zstd compression codec is used. Lowering this size will lower the shuffle memory usage when Zstd is used, but it might increase the compression cost because of excessive JNI call overhead. This configuration only applies to `spark.io.compression.codec`.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.io.compression.zstd.bufferPool.enabled",
    "Default": "true",
    "Meaning": "If true, enable buffer pool of ZSTD JNI library.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kryo.classesToRegister",
    "Default": "(none)",
    "Meaning": "If you use Kryo serialization, give a comma-separated list of custom class names to register with Kryo. See the tuning guide for more details.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.kryo.referenceTracking",
    "Default": "true",
    "Meaning": "Whether to track references to the same object when serializing data with Kryo, which is necessary if your object graphs have loops and useful for efficiency if they contain multiple copies of the same object. Can be disabled to improve performance if you know this is not the case.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.kryo.registrationRequired",
    "Default": "false",
    "Meaning": "Whether to require registration with Kryo. If set to \u0027true\u0027, Kryo will throw an exception if an unregistered class is serialized. If set to false (the default), Kryo will write unregistered class names along with each object. Writing class names can cause significant performance overhead, so enabling this option can enforce strictly that a user has not omitted classes from registration.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.kryo.registrator",
    "Default": "(none)",
    "Meaning": "If you use Kryo serialization, give a comma-separated list of classes that register your custom classes with Kryo. This property is useful if you need to register your classes in a custom way, e.g. to specify a custom field serializer. Otherwise spark.kryo.classesToRegister is simpler. It should be set to classes that extend KryoRegistrator. See the tuning guide for more details.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.kryo.unsafe",
    "Default": "true",
    "Meaning": "Whether to use unsafe based Kryo serializer. Can be substantially faster by using Unsafe Based IO.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.kryoserializer.buffer.max",
    "Default": "64m",
    "Meaning": "Maximum allowable size of Kryo serialization buffer, in MiB unless otherwise specified. This must be larger than any object you attempt to serialize and must be less than 2048m. Increase this if you get a \"buffer limit exceeded\" exception inside Kryo.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.kryoserializer.buffer",
    "Default": "64k",
    "Meaning": "Initial size of Kryo\u0027s serialization buffer, in KiB unless otherwise specified. Note that there will be one buffer per core on each worker. This buffer will grow up to spark.kryoserializer.buffer.max if needed.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.rdd.compress",
    "Default": "false",
    "Meaning": "Whether to compress serialized RDD partitions (e.g. for StorageLevel.MEMORY_ONLY_SER in Java and Scala or StorageLevel.MEMORY_ONLY in Python). Can save substantial space at the cost of some extra CPU time. Compression will use spark.io.compression.codec.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.serializer",
    "Default": "org.apache.spark.serializer. JavaSerializer",
    "Meaning": "Class to use for serializing objects that will be sent over the network or need to be cached in serialized form. The default of Java serialization works with any Serializable Java object but is quite slow, so we recommend using org.apache.spark.serializer.KryoSerializer and configuring Kryo serialization when speed is necessary. Can be any subclass of org.apache.spark.Serializer.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.serializer.objectStreamReset",
    "Default": "100",
    "Meaning": "When serializing using org.apache.spark.serializer.JavaSerializer, the serializer caches objects to prevent writing redundant data, however that stops garbage collection of those objects. By calling \u0027reset\u0027 you flush that info from the serializer, and allow old objects to be collected. To turn off this periodic reset set it to -1. By default it will reset the serializer every 100 objects.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.memory.fraction",
    "Default": "0.6",
    "Meaning": "Fraction of (heap space - 300MB) used for execution and storage. The lower this is, the more frequently spills and cached data eviction occur. The purpose of this config is to set aside memory for internal metadata, user data structures, and imprecise size estimation in the case of sparse, unusually large records. Leaving this at the default value is recommended. For more detail, including important information about correctly tuning JVM garbage collection when increasing this value, see this description.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.memory.storageFraction",
    "Default": "0.5",
    "Meaning": "Amount of storage memory immune to eviction, expressed as a fraction of the size of the region set aside by spark.memory.fraction. The higher this is, the less working memory may be available to execution and tasks may spill to disk more often. Leaving this at the default value is recommended. For more detail, see this description.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.memory.offHeap.enabled",
    "Default": "false",
    "Meaning": "If true, Spark will attempt to use off-heap memory for certain operations. If off-heap memory use is enabled, then spark.memory.offHeap.size must be positive.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.memory.offHeap.size",
    "Default": "0",
    "Meaning": "The absolute amount of memory which can be used for off-heap allocation, in bytes unless otherwise specified. This setting has no impact on heap memory usage, so if your executors\u0027 total memory consumption must fit within some hard limit then be sure to shrink your JVM heap size accordingly. This must be set to a positive value when spark.memory.offHeap.enabled\u003dtrue.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.storage.unrollMemoryThreshold",
    "Default": "1024 * 1024",
    "Meaning": "Initial memory to request before unrolling any block.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.storage.replication.proactive",
    "Default": "true",
    "Meaning": "Enables proactive block replication for RDD blocks. Cached RDD block replicas lost due to executor failures are replenished if there are any existing available replicas. This tries to get the replication level of the block to the initial number.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.storage.localDiskByExecutors.cacheSize",
    "Default": "1000",
    "Meaning": "The max number of executors for which the local dirs are stored. This size is both applied for the driver and both for the executors side to avoid having an unbounded store. This cache will be used to avoid the network in case of fetching disk persisted RDD blocks or shuffle blocks (when spark.shuffle.readHostLocalDisk is set) from the same host.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.cleaner.periodicGC.interval",
    "Default": "30min",
    "Meaning": "Controls how often to trigger a garbage collection. This context cleaner triggers cleanups only when weak references are garbage collected. In long-running applications with large driver JVMs, where there is little memory pressure on the driver, this may happen very occasionally or not at all. Not cleaning at all may lead to executors running out of disk space after a while.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.cleaner.referenceTracking",
    "Default": "true",
    "Meaning": "Enables or disables context cleaning.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.cleaner.referenceTracking.blocking",
    "Default": "true",
    "Meaning": "Controls whether the cleaning thread should block on cleanup tasks (other than shuffle, which is controlled by spark.cleaner.referenceTracking.blocking.shuffle Spark property).",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.cleaner.referenceTracking.blocking.shuffle",
    "Default": "false",
    "Meaning": "Controls whether the cleaning thread should block on shuffle cleanup tasks.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.cleaner.referenceTracking.cleanCheckpoints",
    "Default": "false",
    "Meaning": "Controls whether to clean checkpoint files if the reference is out of scope.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.broadcast.blockSize",
    "Default": "4m",
    "Meaning": "Size of each piece of a block for TorrentBroadcastFactory, in KiB unless otherwise specified. Too large a value decreases parallelism during broadcast (makes it slower); however, if it is too small, BlockManager might take a performance hit.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.broadcast.checksum",
    "Default": "true",
    "Meaning": "Whether to enable checksum for broadcast. If enabled, broadcasts will include a checksum, which can help detect corrupted blocks, at the cost of computing and sending a little more data. It\u0027s possible to disable it if the network has other mechanisms to guarantee data won\u0027t be corrupted during broadcast.",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "spark.broadcast.UDFCompressionThreshold",
    "Default": "1 * 1024 * 1024",
    "Meaning": "The threshold at which user-defined functions (UDFs) and Python RDD commands are compressed by broadcast in bytes unless otherwise specified.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.cores",
    "Default": "1 in YARN mode, all the available cores on the worker in standalone and Mesos coarse-grained modes.",
    "Meaning": "The number of cores to use on each executor. In standalone and Mesos coarse-grained modes, for more detail, see this description.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.default.parallelism",
    "Default": "For distributed shuffle operations like reduceByKey and join, the largest number of partitions in a parent RDD. For operations like parallelize with no parent RDDs, it depends on the cluster manager: Local mode: number of cores on the local machine Mesos fine grained mode: 8 Others: total number of cores on all executor nodes or 2, whichever is larger",
    "Meaning": "Default number of partitions in RDDs returned by transformations like join, reduceByKey, and parallelize when not set by user.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.executor.heartbeatInterval",
    "Default": "10s",
    "Meaning": "Interval between each executor\u0027s heartbeats to the driver. Heartbeats let the driver know that the executor is still alive and update it with metrics for in-progress tasks. spark.executor.heartbeatInterval should be significantly less than spark.network.timeout",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.files.fetchTimeout",
    "Default": "60s",
    "Meaning": "Communication timeout to use when fetching files added through SparkContext.addFile() from the driver.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.files.useFetchCache",
    "Default": "true",
    "Meaning": "If set to true (default), file fetching will use a local cache that is shared by executors that belong to the same application, which can improve task launching performance when running many executors on the same host. If set to false, these caching optimizations will be disabled and all executors will fetch their own copies of files. This optimization may be disabled in order to use Spark local directories that reside on NFS filesystems (see SPARK-6313 for more details).",
    "Since Version": "1.2.2"
  },
  {
    "Property Name": "spark.files.overwrite",
    "Default": "false",
    "Meaning": "Whether to overwrite any files which exist at the startup. Users can not overwrite the files added by SparkContext.addFile or SparkContext.addJar before even if this option is set true.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.files.ignoreCorruptFiles",
    "Default": "false",
    "Meaning": "Whether to ignore corrupt files. If true, the Spark jobs will continue to run when encountering corrupted or non-existing files and contents that have been read will still be returned.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.files.ignoreMissingFiles",
    "Default": "false",
    "Meaning": "Whether to ignore missing files. If true, the Spark jobs will continue to run when encountering missing files and the contents that have been read will still be returned.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.files.maxPartitionBytes",
    "Default": "134217728 (128 MiB)",
    "Meaning": "The maximum number of bytes to pack into a single partition when reading files.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.files.openCostInBytes",
    "Default": "4194304 (4 MiB)",
    "Meaning": "The estimated cost to open a file, measured by the number of bytes could be scanned at the same time. This is used when putting multiple files into a partition. It is better to overestimate, then the partitions with small files will be faster than partitions with bigger files.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.hadoop.cloneConf",
    "Default": "false",
    "Meaning": "If set to true, clones a new Hadoop Configuration object for each task. This option should be enabled to work around Configuration thread-safety issues (see SPARK-2546 for more details). This is disabled by default in order to avoid unexpected performance regressions for jobs that are not affected by these issues.",
    "Since Version": "1.0.3"
  },
  {
    "Property Name": "spark.hadoop.validateOutputSpecs",
    "Default": "true",
    "Meaning": "If set to true, validates the output specification (e.g. checking if the output directory already exists) used in saveAsHadoopFile and other variants. This can be disabled to silence exceptions due to pre-existing output directories. We recommend that users do not disable this except if trying to achieve compatibility with previous versions of Spark. Simply use Hadoop\u0027s FileSystem API to delete output directories by hand. This setting is ignored for jobs generated through Spark Streaming\u0027s StreamingContext, since data may need to be rewritten to pre-existing output directories during checkpoint recovery.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.storage.memoryMapThreshold",
    "Default": "2m",
    "Meaning": "Size of a block above which Spark memory maps when reading a block from disk. Default unit is bytes, unless specified otherwise. This prevents Spark from memory mapping very small blocks. In general, memory mapping has high overhead for blocks close to or below the page size of the operating system.",
    "Since Version": "0.9.2"
  },
  {
    "Property Name": "spark.storage.decommission.enabled",
    "Default": "false",
    "Meaning": "Whether to decommission the block manager when decommissioning executor.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.storage.decommission.shuffleBlocks.enabled",
    "Default": "true",
    "Meaning": "Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle).",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.storage.decommission.shuffleBlocks.maxThreads",
    "Default": "8",
    "Meaning": "Maximum number of threads to use in migrating shuffle files.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.storage.decommission.rddBlocks.enabled",
    "Default": "true",
    "Meaning": "Whether to transfer RDD blocks during block manager decommissioning.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.storage.decommission.fallbackStorage.path",
    "Default": "(none)",
    "Meaning": "The location for fallback storage during block manager decommissioning. For example, s3a://spark-storage/. In case of empty, fallback storage is disabled. The storage should be managed by TTL because Spark will not clean it up.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.storage.decommission.fallbackStorage.cleanUp",
    "Default": "false",
    "Meaning": "If true, Spark cleans up its fallback storage data during shutting down.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.storage.decommission.shuffleBlocks.maxDiskSize",
    "Default": "(none)",
    "Meaning": "Maximum disk space to use to store shuffle blocks before rejecting remote shuffle blocks. Rejecting remote shuffle blocks means that an executor will not receive any shuffle migrations, and if there are no other executors available for migration then shuffle blocks will be lost unless spark.storage.decommission.fallbackStorage.path is configured.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.hadoop.mapreduce.fileoutputcommitter.algorithm.version",
    "Default": "1",
    "Meaning": "The file output committer algorithm version, valid algorithm version number: 1 or 2. Note that 2 may cause a correctness issue like MAPREDUCE-7282.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.eventLog.logStageExecutorMetrics",
    "Default": "false",
    "Meaning": "Whether to write per-stage peaks of executor metrics (for each executor) to the event log. Note: The metrics are polled (collected) and sent in the executor heartbeat, and this is always done; this configuration is only to determine if aggregated metric peaks are written to the event log.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.processTreeMetrics.enabled",
    "Default": "false",
    "Meaning": "Whether to collect process tree metrics (from the /proc filesystem) when collecting executor metrics. Note: The process tree metrics are collected only if the /proc filesystem exists.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.metrics.pollingInterval",
    "Default": "0",
    "Meaning": "How often to collect executor metrics (in milliseconds). If 0, the polling is done on executor heartbeats (thus at the heartbeat interval, specified by spark.executor.heartbeatInterval). If positive, the polling is done at this interval.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.eventLog.gcMetrics.youngGenerationGarbageCollectors",
    "Default": "Copy,PS Scavenge,ParNew,G1 Young Generation",
    "Meaning": "Names of supported young generation garbage collector. A name usually is the return of GarbageCollectorMXBean.getName. The built-in young generation garbage collectors are Copy,PS Scavenge,ParNew,G1 Young Generation.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.eventLog.gcMetrics.oldGenerationGarbageCollectors",
    "Default": "MarkSweepCompact,PS MarkSweep,ConcurrentMarkSweep,G1 Old Generation",
    "Meaning": "Names of supported old generation garbage collector. A name usually is the return of GarbageCollectorMXBean.getName. The built-in old generation garbage collectors are MarkSweepCompact,PS MarkSweep,ConcurrentMarkSweep,G1 Old Generation.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.executor.metrics.fileSystemSchemes",
    "Default": "file,hdfs",
    "Meaning": "The file system schemes to report in executor metrics.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.rpc.message.maxSize",
    "Default": "128",
    "Meaning": "Maximum message size (in MiB) to allow in \"control plane\" communication; generally only applies to map output size information sent between executors and the driver. Increase this if you are running jobs with many thousands of map and reduce tasks and see messages about the RPC message size.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.blockManager.port",
    "Default": "(random)",
    "Meaning": "Port for all block managers to listen on. These exist on both the driver and the executors.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.driver.blockManager.port",
    "Default": "(value of spark.blockManager.port)",
    "Meaning": "Driver-specific port for the block manager to listen on, for cases where it cannot use the same configuration as executors.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.driver.bindAddress",
    "Default": "(value of spark.driver.host)",
    "Meaning": "Hostname or IP address where to bind listening sockets. This config overrides the SPARK_LOCAL_IP environment variable (see below). It also allows a different address from the local one to be advertised to executors or external systems. This is useful, for example, when running containers with bridged networking. For this to properly work, the different ports used by the driver (RPC, block manager and UI) need to be forwarded from the container\u0027s host.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.driver.host",
    "Default": "(local hostname)",
    "Meaning": "Hostname or IP address for the driver. This is used for communicating with the executors and the standalone Master.",
    "Since Version": "0.7.0"
  },
  {
    "Property Name": "spark.driver.port",
    "Default": "(random)",
    "Meaning": "Port for the driver to listen on. This is used for communicating with the executors and the standalone Master.",
    "Since Version": "0.7.0"
  },
  {
    "Property Name": "spark.rpc.io.backLog",
    "Default": "64",
    "Meaning": "Length of the accept queue for the RPC server. For large applications, this value may need to be increased, so that incoming connections are not dropped when a large number of connections arrives in a short period of time.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.network.timeout",
    "Default": "120s",
    "Meaning": "Default timeout for all network interactions. This config will be used in place of spark.storage.blockManagerHeartbeatTimeoutMs, spark.shuffle.io.connectionTimeout, spark.rpc.askTimeout or spark.rpc.lookupTimeout if they are not configured.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.network.timeoutInterval",
    "Default": "60s",
    "Meaning": "Interval for the driver to check and expire dead executors.",
    "Since Version": "1.3.2"
  },
  {
    "Property Name": "spark.network.io.preferDirectBufs",
    "Default": "true",
    "Meaning": "If enabled then off-heap buffer allocations are preferred by the shared allocators. Off-heap buffers are used to reduce garbage collection during shuffle and cache block transfer. For environments where off-heap memory is tightly limited, users may wish to turn this off to force all allocations to be on-heap.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.port.maxRetries",
    "Default": "16",
    "Meaning": "Maximum number of retries when binding to a port before giving up. When a port is given a specific value (non 0), each subsequent retry will increment the port used in the previous attempt by 1 before retrying. This essentially allows it to try a range of ports from the start port specified to port + maxRetries.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.rpc.askTimeout",
    "Default": "spark.network.timeout",
    "Meaning": "Duration for an RPC ask operation to wait before timing out.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.rpc.lookupTimeout",
    "Default": "120s",
    "Meaning": "Duration for an RPC remote endpoint lookup operation to wait before timing out.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.network.maxRemoteBlockSizeFetchToMem",
    "Default": "200m",
    "Meaning": "Remote block will be fetched to disk when size of the block is above this threshold in bytes. This is to avoid a giant request takes too much memory. Note this configuration will affect both shuffle fetch and block manager remote block fetch. For users who enabled external shuffle service, this feature can only work when external shuffle service is at least 2.3.0.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.rpc.io.connectionTimeout",
    "Default": "value of spark.network.timeout",
    "Meaning": "Timeout for the established connections between RPC peers to be marked as idled and closed if there are outstanding RPC requests but no traffic on the channel for at least `connectionTimeout`.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.rpc.io.connectionCreationTimeout",
    "Default": "value of spark.rpc.io.connectionTimeout",
    "Meaning": "Timeout for establishing a connection between RPC peers.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.cores.max",
    "Default": "(not set)",
    "Meaning": "When running on a standalone deploy cluster or a Mesos cluster in \"coarse-grained\" sharing mode, the maximum amount of CPU cores to request for the application from across the cluster (not from each machine). If not set, the default will be spark.deploy.defaultCores on Spark\u0027s standalone cluster manager, or infinite (all available cores) on Mesos.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.locality.wait",
    "Default": "3s",
    "Meaning": "How long to wait to launch a data-local task before giving up and launching it on a less-local node. The same wait will be used to step through multiple locality levels (process-local, node-local, rack-local and then any). It is also possible to customize the waiting time for each level by setting spark.locality.wait.node, etc. You should increase this setting if your tasks are long and see poor locality, but the default usually works well.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.locality.wait.node",
    "Default": "spark.locality.wait",
    "Meaning": "Customize the locality wait for node locality. For example, you can set this to 0 to skip node locality and search immediately for rack locality (if your cluster has rack information).",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.locality.wait.process",
    "Default": "spark.locality.wait",
    "Meaning": "Customize the locality wait for process locality. This affects tasks that attempt to access cached data in a particular executor process.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.locality.wait.rack",
    "Default": "spark.locality.wait",
    "Meaning": "Customize the locality wait for rack locality.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.scheduler.maxRegisteredResourcesWaitingTime",
    "Default": "30s",
    "Meaning": "Maximum amount of time to wait for resources to register before scheduling begins.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.scheduler.minRegisteredResourcesRatio",
    "Default": "0.8 for KUBERNETES mode; 0.8 for YARN mode; 0.0 for standalone mode and Mesos coarse-grained mode",
    "Meaning": "The minimum ratio of registered resources (registered resources / total expected resources) (resources are executors in yarn mode and Kubernetes mode, CPU cores in standalone mode and Mesos coarse-grained mode [\u0027spark.cores.max\u0027 value is total expected resources for Mesos coarse-grained mode] ) to wait for before scheduling begins. Specified as a double between 0.0 and 1.0. Regardless of whether the minimum ratio of resources has been reached, the maximum amount of time it will wait before scheduling begins is controlled by config spark.scheduler.maxRegisteredResourcesWaitingTime.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.scheduler.mode",
    "Default": "FIFO",
    "Meaning": "The scheduling mode between jobs submitted to the same SparkContext. Can be set to FAIR to use fair sharing instead of queueing jobs one after another. Useful for multi-user services.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.scheduler.revive.interval",
    "Default": "1s",
    "Meaning": "The interval length for the scheduler to revive the worker resource offers to run tasks.",
    "Since Version": "0.8.1"
  },
  {
    "Property Name": "spark.scheduler.listenerbus.eventqueue.capacity",
    "Default": "10000",
    "Meaning": "The default capacity for event queues. Spark will try to initialize an event queue using capacity specified by `spark.scheduler.listenerbus.eventqueue.queueName.capacity` first. If it\u0027s not configured, Spark will use the default capacity specified by this config. Note that capacity must be greater than 0. Consider increasing value (e.g. 20000) if listener events are dropped. Increasing this value may result in the driver using more memory.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.scheduler.listenerbus.eventqueue.shared.capacity",
    "Default": "spark.scheduler.listenerbus.eventqueue.capacity",
    "Meaning": "Capacity for shared event queue in Spark listener bus, which hold events for external listener(s) that register to the listener bus. Consider increasing value, if the listener events corresponding to shared queue are dropped. Increasing this value may result in the driver using more memory.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.scheduler.listenerbus.eventqueue.appStatus.capacity",
    "Default": "spark.scheduler.listenerbus.eventqueue.capacity",
    "Meaning": "Capacity for appStatus event queue, which hold events for internal application status listeners. Consider increasing value, if the listener events corresponding to appStatus queue are dropped. Increasing this value may result in the driver using more memory.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.scheduler.listenerbus.eventqueue.executorManagement.capacity",
    "Default": "spark.scheduler.listenerbus.eventqueue.capacity",
    "Meaning": "Capacity for executorManagement event queue in Spark listener bus, which hold events for internal executor management listeners. Consider increasing value if the listener events corresponding to executorManagement queue are dropped. Increasing this value may result in the driver using more memory.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.scheduler.listenerbus.eventqueue.eventLog.capacity",
    "Default": "spark.scheduler.listenerbus.eventqueue.capacity",
    "Meaning": "Capacity for eventLog queue in Spark listener bus, which hold events for Event logging listeners that write events to eventLogs. Consider increasing value if the listener events corresponding to eventLog queue are dropped. Increasing this value may result in the driver using more memory.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.scheduler.listenerbus.eventqueue.streams.capacity",
    "Default": "spark.scheduler.listenerbus.eventqueue.capacity",
    "Meaning": "Capacity for streams queue in Spark listener bus, which hold events for internal streaming listener. Consider increasing value if the listener events corresponding to streams queue are dropped. Increasing this value may result in the driver using more memory.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.scheduler.resource.profileMergeConflicts",
    "Default": "false",
    "Meaning": "If set to \"true\", Spark will merge ResourceProfiles when different profiles are specified in RDDs that get combined into a single stage. When they are merged, Spark chooses the maximum of each resource and creates a new ResourceProfile. The default of false results in Spark throwing an exception if multiple different ResourceProfiles are found in RDDs going into the same stage.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.scheduler.excludeOnFailure.unschedulableTaskSetTimeout",
    "Default": "120s",
    "Meaning": "The timeout in seconds to wait to acquire a new executor and schedule a task before aborting a TaskSet which is unschedulable because all executors are excluded due to task failures.",
    "Since Version": "2.4.1"
  },
  {
    "Property Name": "spark.standalone.submit.waitAppCompletion",
    "Default": "false",
    "Meaning": "If set to true, Spark will merge ResourceProfiles when different profiles are specified in RDDs that get combined into a single stage. When they are merged, Spark chooses the maximum of each resource and creates a new ResourceProfile. The default of false results in Spark throwing an exception if multiple different ResourceProfiles are found in RDDs going into the same stage.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.enabled",
    "Default": "false",
    "Meaning": "If set to \"true\", prevent Spark from scheduling tasks on executors that have been excluded due to too many task failures. The algorithm used to exclude executors and nodes can be further controlled by the other \"spark.excludeOnFailure\" configuration options.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.timeout",
    "Default": "1h",
    "Meaning": "(Experimental) How long a node or executor is excluded for the entire application, before it is unconditionally removed from the excludelist to attempt running new tasks.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.task.maxTaskAttemptsPerExecutor",
    "Default": "1",
    "Meaning": "(Experimental) For a given task, how many times it can be retried on one executor before the executor is excluded for that task.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.task.maxTaskAttemptsPerNode",
    "Default": "2",
    "Meaning": "(Experimental) For a given task, how many times it can be retried on one node, before the entire node is excluded for that task.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.stage.maxFailedTasksPerExecutor",
    "Default": "2",
    "Meaning": "(Experimental) How many different tasks must fail on one executor, within one stage, before the executor is excluded for that stage.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.stage.maxFailedExecutorsPerNode",
    "Default": "2",
    "Meaning": "(Experimental) How many different executors are marked as excluded for a given stage, before the entire node is marked as failed for the stage.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.application.maxFailedTasksPerExecutor",
    "Default": "2",
    "Meaning": "(Experimental) How many different tasks must fail on one executor, in successful task sets, before the executor is excluded for the entire application. Excluded executors will be automatically added back to the pool of available resources after the timeout specified by spark.excludeOnFailure.timeout. Note that with dynamic allocation, though, the executors may get marked as idle and be reclaimed by the cluster manager.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.application.maxFailedExecutorsPerNode",
    "Default": "2",
    "Meaning": "(Experimental) How many different executors must be excluded for the entire application, before the node is excluded for the entire application. Excluded nodes will be automatically added back to the pool of available resources after the timeout specified by spark.excludeOnFailure.timeout. Note that with dynamic allocation, though, the executors on the node may get marked as idle and be reclaimed by the cluster manager.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.killExcludedExecutors",
    "Default": "false",
    "Meaning": "(Experimental) If set to \"true\", allow Spark to automatically kill the executors when they are excluded on fetch failure or excluded for the entire application, as controlled by spark.killExcludedExecutors.application.*. Note that, when an entire node is added excluded, all of the executors on that node will be killed.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.excludeOnFailure.application.fetchFailure.enabled",
    "Default": "false",
    "Meaning": "(Experimental) If set to \"true\", Spark will exclude the executor immediately when a fetch failure happens. If external shuffle service is enabled, then the whole node will be excluded.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.speculation",
    "Default": "false",
    "Meaning": "If set to \"true\", performs speculative execution of tasks. This means if one or more tasks are running slowly in a stage, they will be re-launched.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.speculation.interval",
    "Default": "100ms",
    "Meaning": "How often Spark will check for tasks to speculate.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.speculation.multiplier",
    "Default": "1.5",
    "Meaning": "How many times slower a task is than the median to be considered for speculation.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.speculation.quantile",
    "Default": "0.75",
    "Meaning": "Fraction of tasks which must be complete before speculation is enabled for a particular stage.",
    "Since Version": "0.6.0"
  },
  {
    "Property Name": "spark.speculation.minTaskRuntime",
    "Default": "100ms",
    "Meaning": "Minimum amount of time a task runs before being considered for speculation. This can be used to avoid launching speculative copies of tasks that are very short.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.speculation.task.duration.threshold",
    "Default": "None",
    "Meaning": "Task duration after which scheduler would try to speculative run the task. If provided, tasks would be speculatively run if current stage contains less tasks than or equal to the number of slots on a single executor and the task is taking longer time than the threshold. This config helps speculate stage with very few tasks. Regular speculation configs may also apply if the executor slots are large enough. E.g. tasks might be re-launched if there are enough successful runs even though the threshold hasn\u0027t been reached. The number of slots is computed based on the conf values of spark.executor.cores and spark.task.cpus minimum 1. Default unit is bytes, unless otherwise specified.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.speculation.efficiency.processRateMultiplier",
    "Default": "0.75",
    "Meaning": "A multiplier that used when evaluating inefficient tasks. The higher the multiplier is, the more tasks will be possibly considered as inefficient.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.speculation.efficiency.longRunTaskFactor",
    "Default": "2",
    "Meaning": "A task will be speculated anyway as long as its duration has exceeded the value of multiplying the factor and the time threshold (either be spark.speculation.multiplier * successfulTaskDurations.median or spark.speculation.minTaskRuntime) regardless of it\u0027s data process rate is good or not. This avoids missing the inefficient tasks when task slow isn\u0027t related to data process rate.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.speculation.efficiency.enabled",
    "Default": "true",
    "Meaning": "When set to true, spark will evaluate the efficiency of task processing through the stage task metrics or its duration, and only need to speculate the inefficient tasks. A task is inefficient when 1)its data process rate is less than the average data process rate of all successful tasks in the stage multiplied by a multiplier or 2)its duration has exceeded the value of multiplying spark.speculation.efficiency.longRunTaskFactor and the time threshold (either be spark.speculation.multiplier * successfulTaskDurations.median or spark.speculation.minTaskRuntime).",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.task.cpus",
    "Default": "1",
    "Meaning": "Number of cores to allocate for each task.",
    "Since Version": "0.5.0"
  },
  {
    "Property Name": "spark.task.resource.{resourceName}.amount",
    "Default": "1",
    "Meaning": "Amount of a particular resource type to allocate for each task, note that this can be a double. If this is specified you must also provide the executor config spark.executor.resource.{resourceName}.amount and any corresponding discovery configs so that your executors are created with that resource type. In addition to whole amounts, a fractional amount (for example, 0.25, which means 1/4th of a resource) may be specified. Fractional amounts must be less than or equal to 0.5, or in other words, the minimum amount of resource sharing is 2 tasks per resource. Additionally, fractional amounts are floored in order to assign resource slots (e.g. a 0.2222 configuration, or 1/0.2222 slots will become 4 tasks/resource, not 5).",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.task.maxFailures",
    "Default": "4",
    "Meaning": "Number of continuous failures of any particular task before giving up on the job. The total number of failures spread across different tasks will not cause the job to fail; a particular task has to fail this number of attempts continuously. If any attempt succeeds, the failure count for the task will be reset. Should be greater than or equal to 1. Number of allowed retries \u003d this value - 1.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.task.reaper.enabled",
    "Default": "false",
    "Meaning": "Enables monitoring of killed / interrupted tasks. When set to true, any task which is killed will be monitored by the executor until that task actually finishes executing. See the other spark.task.reaper.* configurations for details on how to control the exact behavior of this monitoring. When set to false (the default), task killing will use an older code path which lacks such monitoring.",
    "Since Version": "2.0.3"
  },
  {
    "Property Name": "spark.task.reaper.pollingInterval",
    "Default": "10s",
    "Meaning": "When spark.task.reaper.enabled \u003d true, this setting controls the frequency at which executors will poll the status of killed tasks. If a killed task is still running when polled then a warning will be logged and, by default, a thread-dump of the task will be logged (this thread dump can be disabled via the spark.task.reaper.threadDump setting, which is documented below).",
    "Since Version": "2.0.3"
  },
  {
    "Property Name": "spark.task.reaper.threadDump",
    "Default": "true",
    "Meaning": "When spark.task.reaper.enabled \u003d true, this setting controls whether task thread dumps are logged during periodic polling of killed tasks. Set this to false to disable collection of thread dumps.",
    "Since Version": "2.0.3"
  },
  {
    "Property Name": "spark.task.reaper.killTimeout",
    "Default": "-1",
    "Meaning": "When spark.task.reaper.enabled \u003d true, this setting specifies a timeout after which the executor JVM will kill itself if a killed task has not stopped running. The default value, -1, disables this mechanism and prevents the executor from self-destructing. The purpose of this setting is to act as a safety-net to prevent runaway noncancellable tasks from rendering an executor unusable.",
    "Since Version": "2.0.3"
  },
  {
    "Property Name": "spark.stage.maxConsecutiveAttempts",
    "Default": "4",
    "Meaning": "Number of consecutive stage attempts allowed before a stage is aborted.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.stage.ignoreDecommissionFetchFailure",
    "Default": "false",
    "Meaning": "Whether ignore stage fetch failure caused by executor decommission when count spark.stage.maxConsecutiveAttempts",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.barrier.sync.timeout",
    "Default": "365d",
    "Meaning": "The timeout in seconds for each barrier() call from a barrier task. If the coordinator didn\u0027t receive all the sync messages from barrier tasks within the configured time, throw a SparkException to fail all the tasks. The default value is set to 31536000(3600 * 24 * 365) so the barrier() call shall wait for one year.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.scheduler.barrier.maxConcurrentTasksCheck.interval",
    "Default": "15s",
    "Meaning": "Time in seconds to wait between a max concurrent tasks check failure and the next check. A max concurrent tasks check ensures the cluster can launch more concurrent tasks than required by a barrier stage on job submitted. The check can fail in case a cluster has just started and not enough executors have registered, so we wait for a little while and try to perform the check again. If the check fails more than a configured max failure times for a job then fail current job submission. Note this config only applies to jobs that contain one or more barrier stages, we won\u0027t perform the check on non-barrier jobs.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.scheduler.barrier.maxConcurrentTasksCheck.maxFailures",
    "Default": "40",
    "Meaning": "Number of max concurrent tasks check failures allowed before fail a job submission. A max concurrent tasks check ensures the cluster can launch more concurrent tasks than required by a barrier stage on job submitted. The check can fail in case a cluster has just started and not enough executors have registered, so we wait for a little while and try to perform the check again. If the check fails more than a configured max failure times for a job then fail current job submission. Note this config only applies to jobs that contain one or more barrier stages, we won\u0027t perform the check on non-barrier jobs.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.enabled",
    "Default": "false",
    "Meaning": "Whether to use dynamic resource allocation, which scales the number of executors registered with this application up and down based on the workload. For more detail, see the description here. This requires one of the following conditions: 1) enabling external shuffle service through spark.shuffle.service.enabled, or 2) enabling shuffle tracking through spark.dynamicAllocation.shuffleTracking.enabled, or 3) enabling shuffle blocks decommission through spark.decommission.enabled and spark.storage.decommission.shuffleBlocks.enabled, or 4) (Experimental) configuring spark.shuffle.sort.io.plugin.class to use a custom ShuffleDataIO who\u0027s ShuffleDriverComponents supports reliable storage. The following configurations are also relevant: spark.dynamicAllocation.minExecutors, spark.dynamicAllocation.maxExecutors, and spark.dynamicAllocation.initialExecutors spark.dynamicAllocation.executorAllocationRatio",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.executorIdleTimeout",
    "Default": "60s",
    "Meaning": "If dynamic allocation is enabled and an executor has been idle for more than this duration, the executor will be removed. For more detail, see this description.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.cachedExecutorIdleTimeout",
    "Default": "infinity",
    "Meaning": "If dynamic allocation is enabled and an executor which has cached data blocks has been idle for more than this duration, the executor will be removed. For more details, see this description.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.initialExecutors",
    "Default": "spark.dynamicAllocation.minExecutors",
    "Meaning": "Initial number of executors to run if dynamic allocation is enabled. If `--num-executors` (or `spark.executor.instances`) is set and larger than this value, it will be used as the initial number of executors.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.maxExecutors",
    "Default": "infinity",
    "Meaning": "Upper bound for the number of executors if dynamic allocation is enabled.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.minExecutors",
    "Default": "0",
    "Meaning": "Lower bound for the number of executors if dynamic allocation is enabled.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.executorAllocationRatio",
    "Default": "1",
    "Meaning": "By default, the dynamic allocation will request enough executors to maximize the parallelism according to the number of tasks to process. While this minimizes the latency of the job, with small tasks this setting can waste a lot of resources due to executor allocation overhead, as some executor might not even do any work. This setting allows to set a ratio that will be used to reduce the number of executors w.r.t. full parallelism. Defaults to 1.0 to give maximum parallelism. 0.5 will divide the target number of executors by 2 The target number of executors computed by the dynamicAllocation can still be overridden by the spark.dynamicAllocation.minExecutors and spark.dynamicAllocation.maxExecutors settings",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.schedulerBacklogTimeout",
    "Default": "1s",
    "Meaning": "If dynamic allocation is enabled and there have been pending tasks backlogged for more than this duration, new executors will be requested. For more detail, see this description.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.sustainedSchedulerBacklogTimeout",
    "Default": "schedulerBacklogTimeout",
    "Meaning": "Same as spark.dynamicAllocation.schedulerBacklogTimeout, but used only for subsequent executor requests. For more detail, see this description.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.shuffleTracking.enabled",
    "Default": "true",
    "Meaning": "Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.dynamicAllocation.shuffleTracking.timeout",
    "Default": "infinity",
    "Meaning": "When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.{driver|executor}.rpc.io.serverThreads",
    "Default": "Fall back on spark.rpc.io.serverThreads",
    "Meaning": "Number of threads used in the server thread pool",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.{driver|executor}.rpc.io.clientThreads",
    "Default": "Fall back on spark.rpc.io.clientThreads",
    "Meaning": "Number of threads used in the client thread pool",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.{driver|executor}.rpc.netty.dispatcher.numThreads",
    "Default": "Fall back on spark.rpc.netty.dispatcher.numThreads",
    "Meaning": "Number of threads used in RPC message dispatcher thread pool",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.connect.grpc.binding.port",
    "Default": "15002",
    "Meaning": "Port for Spark Connect server to bind.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.connect.grpc.interceptor.classes",
    "Default": "(none)",
    "Meaning": "Comma separated list of class names that must implement the io.grpc.ServerInterceptor interface",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.connect.grpc.arrow.maxBatchSize",
    "Default": "4m",
    "Meaning": "When using Apache Arrow, limit the maximum size of one arrow batch that can be sent from server side to client side. Currently, we conservatively use 70% of it because the size is not accurate but estimated.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.connect.grpc.maxInboundMessageSize",
    "Default": "134217728",
    "Meaning": "Sets the maximum inbound message size for the gRPC requests. Requests with a larger payload will fail.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.connect.extensions.relation.classes",
    "Default": "(none)",
    "Meaning": "Comma separated list of classes that implement the trait org.apache.spark.sql.connect.plugin.RelationPlugin to support custom Relation types in proto.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.connect.extensions.expression.classes",
    "Default": "(none)",
    "Meaning": "Comma separated list of classes that implement the trait org.apache.spark.sql.connect.plugin.ExpressionPlugin to support custom Expression types in proto.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.connect.extensions.command.classes",
    "Default": "(none)",
    "Meaning": "Comma separated list of classes that implement the trait org.apache.spark.sql.connect.plugin.CommandPlugin to support custom Command types in proto.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.adaptive.advisoryPartitionSizeInBytes",
    "Default": "(value of spark.sql.adaptive.shuffle.targetPostShuffleInputSize)",
    "Meaning": "The advisory size in bytes of the shuffle partition during adaptive optimization (when spark.sql.adaptive.enabled is true). It takes effect when Spark coalesces small shuffle partitions or splits skewed shuffle partition.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.adaptive.autoBroadcastJoinThreshold",
    "Default": "(none)",
    "Meaning": "Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join. By setting this value to -1 broadcasting can be disabled. The default value is same with spark.sql.autoBroadcastJoinThreshold. Note that, this config is used only in adaptive framework.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.adaptive.coalescePartitions.enabled",
    "Default": "true",
    "Meaning": "When true and \u0027spark.sql.adaptive.enabled\u0027 is true, Spark will coalesce contiguous shuffle partitions according to the target size (specified by \u0027spark.sql.adaptive.advisoryPartitionSizeInBytes\u0027), to avoid too many small tasks.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.adaptive.coalescePartitions.initialPartitionNum",
    "Default": "(none)",
    "Meaning": "The initial number of shuffle partitions before coalescing. If not set, it equals to spark.sql.shuffle.partitions. This configuration only has an effect when \u0027spark.sql.adaptive.enabled\u0027 and \u0027spark.sql.adaptive.coalescePartitions.enabled\u0027 are both true.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.adaptive.coalescePartitions.minPartitionSize",
    "Default": "1MB",
    "Meaning": "The minimum size of shuffle partitions after coalescing. This is useful when the adaptively calculated target size is too small during partition coalescing.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.adaptive.coalescePartitions.parallelismFirst",
    "Default": "true",
    "Meaning": "When true, Spark does not respect the target size specified by \u0027spark.sql.adaptive.advisoryPartitionSizeInBytes\u0027 (default 64MB) when coalescing contiguous shuffle partitions, but adaptively calculate the target size according to the default parallelism of the Spark cluster. The calculated size is usually smaller than the configured target size. This is to maximize the parallelism and avoid performance regression when enabling adaptive query execution. It\u0027s recommended to set this config to false and respect the configured target size.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.adaptive.customCostEvaluatorClass",
    "Default": "(none)",
    "Meaning": "The custom cost evaluator class to be used for adaptive execution. If not being set, Spark will use its own SimpleCostEvaluator by default.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.adaptive.enabled",
    "Default": "true",
    "Meaning": "When true, enable adaptive query execution, which re-optimizes the query plan in the middle of query execution, based on accurate runtime statistics.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.sql.adaptive.forceOptimizeSkewedJoin",
    "Default": "false",
    "Meaning": "When true, force enable OptimizeSkewedJoin even if it introduces extra shuffle.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.adaptive.localShuffleReader.enabled",
    "Default": "true",
    "Meaning": "When true and \u0027spark.sql.adaptive.enabled\u0027 is true, Spark tries to use local shuffle reader to read the shuffle data when the shuffle partitioning is not needed, for example, after converting sort-merge join to broadcast-hash join.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.adaptive.maxShuffledHashJoinLocalMapThreshold",
    "Default": "0b",
    "Meaning": "Configures the maximum size in bytes per partition that can be allowed to build local hash map. If this value is not smaller than spark.sql.adaptive.advisoryPartitionSizeInBytes and all the partition size are not larger than this config, join selection prefer to use shuffled hash join instead of sort merge join regardless of the value of spark.sql.join.preferSortMergeJoin.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.adaptive.optimizeSkewsInRebalancePartitions.enabled",
    "Default": "true",
    "Meaning": "When true and \u0027spark.sql.adaptive.enabled\u0027 is true, Spark will optimize the skewed shuffle partitions in RebalancePartitions and split them to smaller ones according to the target size (specified by \u0027spark.sql.adaptive.advisoryPartitionSizeInBytes\u0027), to avoid data skew.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.adaptive.optimizer.excludedRules",
    "Default": "(none)",
    "Meaning": "Configures a list of rules to be disabled in the adaptive optimizer, in which the rules are specified by their rule names and separated by comma. The optimizer will log the rules that have indeed been excluded.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.adaptive.rebalancePartitionsSmallPartitionFactor",
    "Default": "0.2",
    "Meaning": "A partition will be merged during splitting if its size is small than this factor multiply spark.sql.adaptive.advisoryPartitionSizeInBytes.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.adaptive.skewJoin.enabled",
    "Default": "true",
    "Meaning": "When true and \u0027spark.sql.adaptive.enabled\u0027 is true, Spark dynamically handles skew in shuffled join (sort-merge and shuffled hash) by splitting (and replicating if needed) skewed partitions.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.adaptive.skewJoin.skewedPartitionFactor",
    "Default": "5.0",
    "Meaning": "A partition is considered as skewed if its size is larger than this factor multiplying the median partition size and also larger than \u0027spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes\u0027",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes",
    "Default": "256MB",
    "Meaning": "A partition is considered as skewed if its size in bytes is larger than this threshold and also larger than \u0027spark.sql.adaptive.skewJoin.skewedPartitionFactor\u0027 multiplying the median partition size. Ideally this config should be set larger than \u0027spark.sql.adaptive.advisoryPartitionSizeInBytes\u0027.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.allowNamedFunctionArguments",
    "Default": "true",
    "Meaning": "If true, Spark will turn on support for named parameters for all functions that has it implemented.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.sql.ansi.doubleQuotedIdentifiers",
    "Default": "false",
    "Meaning": "When true and \u0027spark.sql.ansi.enabled\u0027 is true, Spark SQL reads literals enclosed in double quoted (\") as identifiers. When false they are read as string literals.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.ansi.enabled",
    "Default": "false",
    "Meaning": "When true, Spark SQL uses an ANSI compliant dialect instead of being Hive compliant. For example, Spark will throw an exception at runtime instead of returning null results when the inputs to a SQL operator/function are invalid.For full details of this dialect, you can find them in the section \"ANSI Compliance\" of Spark\u0027s documentation. Some ANSI dialect features may be not from the ANSI SQL standard directly, but their behaviors align with ANSI SQL\u0027s style",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.ansi.enforceReservedKeywords",
    "Default": "false",
    "Meaning": "When true and \u0027spark.sql.ansi.enabled\u0027 is true, the Spark SQL parser enforces the ANSI reserved keywords and forbids SQL queries that use reserved keywords as alias names and/or identifiers for table, view, function, etc.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.ansi.relationPrecedence",
    "Default": "false",
    "Meaning": "When true and \u0027spark.sql.ansi.enabled\u0027 is true, JOIN takes precedence over comma when combining relation. For example, t1, t2 JOIN t3 should result to t1 X (t2 X t3). If the config is false, the result is (t1 X t2) X t3.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.autoBroadcastJoinThreshold",
    "Default": "10MB",
    "Meaning": "Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join. By setting this value to -1 broadcasting can be disabled. Note that currently statistics are only supported for Hive Metastore tables where the command ANALYZE TABLE \u003ctableName\u003e COMPUTE STATISTICS noscan has been run, and file-based data source tables where the statistics are computed directly on the files of data.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.sql.avro.compression.codec",
    "Default": "snappy",
    "Meaning": "Compression codec used in writing of AVRO files. Supported codecs: uncompressed, deflate, snappy, bzip2, xz and zstandard. Default codec is snappy.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.avro.deflate.level",
    "Default": "-1",
    "Meaning": "Compression level for the deflate codec used in writing of AVRO files. Valid value must be in the range of from 1 to 9 inclusive or -1. The default value is -1 which corresponds to 6 level in the current implementation.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.avro.filterPushdown.enabled",
    "Default": "true",
    "Meaning": "When true, enable filter pushdown to Avro datasource.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.broadcastTimeout",
    "Default": "300",
    "Meaning": "Timeout in seconds for the broadcast wait time in broadcast joins.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.sql.bucketing.coalesceBucketsInJoin.enabled",
    "Default": "false",
    "Meaning": "When true, if two bucketed tables with the different number of buckets are joined, the side with a bigger number of buckets will be coalesced to have the same number of buckets as the other side. Bigger number of buckets is divisible by the smaller number of buckets. Bucket coalescing is applied to sort-merge joins and shuffled hash join. Note: Coalescing bucketed table can avoid unnecessary shuffling in join, but it also reduces parallelism and could possibly cause OOM for shuffled hash join.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.bucketing.coalesceBucketsInJoin.maxBucketRatio",
    "Default": "4",
    "Meaning": "The ratio of the number of two buckets being coalesced should be less than or equal to this value for bucket coalescing to be applied. This configuration only has an effect when \u0027spark.sql.bucketing.coalesceBucketsInJoin.enabled\u0027 is set to true.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.catalog.spark_catalog",
    "Default": "(none)",
    "Meaning": "A catalog implementation that will be used as the v2 interface to Spark\u0027s built-in v1 catalog: spark_catalog. This catalog shares its identifier namespace with the spark_catalog and must be consistent with it; for example, if a table can be loaded by the spark_catalog, this catalog must also return the table metadata. To delegate operations to the spark_catalog, implementations can extend \u0027CatalogExtension\u0027.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.cbo.enabled",
    "Default": "false",
    "Meaning": "Enables CBO for estimation of plan statistics when set true.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.cbo.joinReorder.dp.star.filter",
    "Default": "false",
    "Meaning": "Applies star-join filter heuristics to cost based join enumeration.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.cbo.joinReorder.dp.threshold",
    "Default": "12",
    "Meaning": "The maximum number of joined nodes allowed in the dynamic programming algorithm.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.cbo.joinReorder.enabled",
    "Default": "false",
    "Meaning": "Enables join reorder in CBO.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.cbo.planStats.enabled",
    "Default": "false",
    "Meaning": "When true, the logical plan will fetch row counts and column statistics from catalog.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.cbo.starSchemaDetection",
    "Default": "false",
    "Meaning": "When true, it enables join reordering based on star schema detection.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.charAsVarchar",
    "Default": "false",
    "Meaning": "When true, Spark replaces CHAR type with VARCHAR type in CREATE/REPLACE/ALTER TABLE commands, so that newly created/updated tables will not have CHAR type columns/fields. Existing tables with CHAR type columns/fields are not affected by this config.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.chunkBase64String.enabled",
    "Default": "true",
    "Meaning": "Whether to truncate string generated by the Base64 function. When true, base64 strings generated by the base64 function are chunked into lines of at most 76 characters. When false, the base64 strings are not chunked.",
    "Since Version": "3.5.2"
  },
  {
    "Property Name": "spark.sql.cli.print.header",
    "Default": "false",
    "Meaning": "When set to true, spark-sql CLI prints the names of the columns in query output.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.columnNameOfCorruptRecord",
    "Default": "_corrupt_record",
    "Meaning": "The name of internal column for storing raw/un-parsed JSON and CSV records that fail to parse.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.sql.csv.filterPushdown.enabled",
    "Default": "true",
    "Meaning": "When true, enable filter pushdown to CSV datasource.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.datetime.java8API.enabled",
    "Default": "false",
    "Meaning": "If the configuration property is set to true, java.time.Instant and java.time.LocalDate classes of Java 8 API are used as external types for Catalyst\u0027s TimestampType and DateType. If it is set to false, java.sql.Timestamp and java.sql.Date are used for the same purpose.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.debug.maxToStringFields",
    "Default": "25",
    "Meaning": "Maximum number of fields of sequence-like entries can be converted to strings in debug output. Any elements beyond the limit will be dropped and replaced by a \"... N more fields\" placeholder.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.defaultCatalog",
    "Default": "spark_catalog",
    "Meaning": "Name of the default catalog. This will be the current catalog if users have not explicitly set the current catalog yet.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.error.messageFormat",
    "Default": "PRETTY",
    "Meaning": "When PRETTY, the error message consists of textual representation of error class, message and query context. The MINIMAL and STANDARD formats are pretty JSON formats where STANDARD includes an additional JSON field message. This configuration property influences on error messages of Thrift Server and SQL CLI while running queries.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.enabled",
    "Default": "false",
    "Meaning": "(Deprecated since Spark 3.0, please set \u0027spark.sql.execution.arrow.pyspark.enabled\u0027.)",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.fallback.enabled",
    "Default": "true",
    "Meaning": "(Deprecated since Spark 3.0, please set \u0027spark.sql.execution.arrow.pyspark.fallback.enabled\u0027.)",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.localRelationThreshold",
    "Default": "48MB",
    "Meaning": "When converting Arrow batches to Spark DataFrame, local collections are used in the driver side if the byte size of Arrow batches is smaller than this threshold. Otherwise, the Arrow batches are sent and deserialized to Spark internal rows in the executors.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.maxRecordsPerBatch",
    "Default": "10000",
    "Meaning": "When using Apache Arrow, limit the maximum number of records that can be written to a single ArrowRecordBatch in memory. This configuration is not effective for the grouping API such as DataFrame(.cogroup).groupby.applyInPandas because each group becomes each ArrowRecordBatch. If set to zero or negative there is no limit.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.pyspark.enabled",
    "Default": "(value of spark.sql.execution.arrow.enabled)",
    "Meaning": "When true, make use of Apache Arrow for columnar data transfers in PySpark. This optimization applies to: 1. pyspark.sql.DataFrame.toPandas. 2. pyspark.sql.SparkSession.createDataFrame when its input is a Pandas DataFrame or a NumPy ndarray. The following data type is unsupported: ArrayType of TimestampType.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.pyspark.fallback.enabled",
    "Default": "(value of spark.sql.execution.arrow.fallback.enabled)",
    "Meaning": "When true, optimizations enabled by \u0027spark.sql.execution.arrow.pyspark.enabled\u0027 will fallback automatically to non-optimized implementations if an error occurs.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.pyspark.selfDestruct.enabled",
    "Default": "false",
    "Meaning": "(Experimental) When true, make use of Apache Arrow\u0027s self-destruct and split-blocks options for columnar data transfers in PySpark, when converting from Arrow to Pandas. This reduces memory usage at the cost of some CPU time. This optimization applies to: pyspark.sql.DataFrame.toPandas when \u0027spark.sql.execution.arrow.pyspark.enabled\u0027 is set.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.execution.arrow.sparkr.enabled",
    "Default": "false",
    "Meaning": "When true, make use of Apache Arrow for columnar data transfers in SparkR. This optimization applies to: 1. createDataFrame when its input is an R DataFrame 2. collect 3. dapply 4. gapply The following data types are unsupported: FloatType, BinaryType, ArrayType, StructType and MapType.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.execution.pandas.structHandlingMode",
    "Default": "legacy",
    "Meaning": "The conversion mode of struct type when creating pandas DataFrame. When \"legacy\",1. when Arrow optimization is disabled, convert to Row object, 2. when Arrow optimization is enabled, convert to dict or raise an Exception if there are duplicated nested field names. When \"row\", convert to Row object regardless of Arrow optimization. When \"dict\", convert to dict and use suffixed key names, e.g., a_0, a_1, if there are duplicated nested field names, regardless of Arrow optimization.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.sql.execution.pandas.udf.buffer.size",
    "Default": "(value of spark.buffer.size)",
    "Meaning": "Same as spark.buffer.size but only applies to Pandas UDF executions. If it is not set, the fallback is spark.buffer.size. Note that Pandas execution requires more than 4 bytes. Lowering this value could make small Pandas UDF batch iterated and pipelined; however, it might degrade performance. See SPARK-27870.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.execution.pyspark.udf.simplifiedTraceback.enabled",
    "Default": "true",
    "Meaning": "When true, the traceback from Python UDFs is simplified. It hides the Python worker, (de)serialization, etc from PySpark in tracebacks, and only shows the exception messages from UDFs. Note that this works only with CPython 3.7+.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.execution.pythonUDF.arrow.enabled",
    "Default": "false",
    "Meaning": "Enable Arrow optimization in regular Python UDFs. This optimization can only be enabled when the given function takes at least one argument.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.execution.pythonUDTF.arrow.enabled",
    "Default": "false",
    "Meaning": "Enable Arrow optimization for Python UDTFs.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.sql.execution.topKSortFallbackThreshold",
    "Default": "2147483632",
    "Meaning": "In SQL queries with a SORT followed by a LIMIT like \u0027SELECT x FROM t ORDER BY y LIMIT m\u0027, if m is under this threshold, do a top-K sort in memory, otherwise do a global sort which spills to disk if necessary.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.files.ignoreCorruptFiles",
    "Default": "false",
    "Meaning": "Whether to ignore corrupt files. If true, the Spark jobs will continue to run when encountering corrupted files and the contents that have been read will still be returned. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "spark.sql.files.ignoreMissingFiles",
    "Default": "false",
    "Meaning": "Whether to ignore missing files. If true, the Spark jobs will continue to run when encountering missing files and the contents that have been read will still be returned. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.files.maxPartitionBytes",
    "Default": "128MB",
    "Meaning": "The maximum number of bytes to pack into a single partition when reading files. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.files.maxPartitionNum",
    "Default": "(none)",
    "Meaning": "The suggested (not guaranteed) maximum number of split file partitions. If it is set, Spark will rescale each partition to make the number of partitions is close to this value if the initial number of partitions exceeds this value. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.sql.files.maxRecordsPerFile",
    "Default": "0",
    "Meaning": "Maximum number of records to write out to a single file. If this value is zero or negative, there is no limit.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.files.minPartitionNum",
    "Default": "(none)",
    "Meaning": "The suggested (not guaranteed) minimum number of split file partitions. If not set, the default value is spark.sql.leafNodeDefaultParallelism. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.function.concatBinaryAsString",
    "Default": "false",
    "Meaning": "When this option is set to false and all inputs are binary, functions.concat returns an output as binary. Otherwise, it returns as a string.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.function.eltOutputAsString",
    "Default": "false",
    "Meaning": "When this option is set to false and all inputs are binary, elt returns an output as binary. Otherwise, it returns as a string.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.groupByAliases",
    "Default": "true",
    "Meaning": "When true, aliases in a select list can be used in group by clauses. When false, an analysis exception is thrown in the case.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.groupByOrdinal",
    "Default": "true",
    "Meaning": "When true, the ordinal numbers in group by clauses are treated as the position in the select list. When false, the ordinal numbers are ignored.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.hive.convertInsertingPartitionedTable",
    "Default": "true",
    "Meaning": "When set to true, and spark.sql.hive.convertMetastoreParquet or spark.sql.hive.convertMetastoreOrc is true, the built-in ORC/Parquet writer is usedto process inserting into partitioned ORC/Parquet tables created by using the HiveSQL syntax.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.hive.convertMetastoreCtas",
    "Default": "true",
    "Meaning": "When set to true, Spark will try to use built-in data source writer instead of Hive serde in CTAS. This flag is effective only if spark.sql.hive.convertMetastoreParquet or spark.sql.hive.convertMetastoreOrc is enabled respectively for Parquet and ORC formats",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.hive.convertMetastoreInsertDir",
    "Default": "true",
    "Meaning": "When set to true, Spark will try to use built-in data source writer instead of Hive serde in INSERT OVERWRITE DIRECTORY. This flag is effective only if spark.sql.hive.convertMetastoreParquet or spark.sql.hive.convertMetastoreOrc is enabled respectively for Parquet and ORC formats",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.hive.convertMetastoreOrc",
    "Default": "true",
    "Meaning": "When set to true, the built-in ORC reader and writer are used to process ORC tables created by using the HiveQL syntax, instead of Hive serde.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.hive.convertMetastoreParquet",
    "Default": "true",
    "Meaning": "When set to true, the built-in Parquet reader and writer are used to process parquet tables created by using the HiveQL syntax, instead of Hive serde.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.sql.hive.convertMetastoreParquet.mergeSchema",
    "Default": "false",
    "Meaning": "When true, also tries to merge possibly different but compatible Parquet schemas in different Parquet data files. This configuration is only effective when \"spark.sql.hive.convertMetastoreParquet\" is true.",
    "Since Version": "1.3.1"
  },
  {
    "Property Name": "spark.sql.hive.dropPartitionByName.enabled",
    "Default": "false",
    "Meaning": "When true, Spark will get partition name rather than partition object to drop partition, which can improve the performance of drop partition.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.hive.filesourcePartitionFileCacheSize",
    "Default": "262144000",
    "Meaning": "When nonzero, enable caching of partition file metadata in memory. All tables share a cache that can use up to specified num bytes for file metadata. This conf only has an effect when hive filesource partition management is enabled.",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "spark.sql.hive.manageFilesourcePartitions",
    "Default": "true",
    "Meaning": "When true, enable metastore partition management for file source tables as well. This includes both datasource and converted Hive tables. When partition management is enabled, datasource tables store partition in the Hive metastore, and use the metastore to prune partitions during query planning when spark.sql.hive.metastorePartitionPruning is set to true.",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "spark.sql.hive.metastorePartitionPruning",
    "Default": "true",
    "Meaning": "When true, some predicates will be pushed down into the Hive metastore so that unmatching partitions can be eliminated earlier.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.hive.metastorePartitionPruningFallbackOnException",
    "Default": "false",
    "Meaning": "Whether to fallback to get all partitions from Hive metastore and perform partition pruning on Spark client side, when encountering MetaException from the metastore. Note that Spark query performance may degrade if this is enabled and there are many partitions to be listed. If this is disabled, Spark will fail the query instead.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.hive.metastorePartitionPruningFastFallback",
    "Default": "false",
    "Meaning": "When this config is enabled, if the predicates are not supported by Hive or Spark does fallback due to encountering MetaException from the metastore, Spark will instead prune partitions by getting the partition names first and then evaluating the filter expressions on the client side. Note that the predicates with TimeZoneAwareExpression is not supported.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.hive.thriftServer.async",
    "Default": "true",
    "Meaning": "When set to true, Hive Thrift server executes SQL queries in an asynchronous way.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.hive.verifyPartitionPath",
    "Default": "false",
    "Meaning": "When true, check all the partition paths under the table\u0027s root directory when reading data stored in HDFS. This configuration will be deprecated in the future releases and replaced by spark.files.ignoreMissingFiles.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.inMemoryColumnarStorage.batchSize",
    "Default": "10000",
    "Meaning": "Controls the size of batches for columnar caching. Larger batch sizes can improve memory utilization and compression, but risk OOMs when caching data.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.sql.inMemoryColumnarStorage.compressed",
    "Default": "true",
    "Meaning": "When set to true Spark SQL will automatically select a compression codec for each column based on statistics of the data.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.sql.inMemoryColumnarStorage.enableVectorizedReader",
    "Default": "true",
    "Meaning": "Enables vectorized reader for columnar caching.",
    "Since Version": "2.3.1"
  },
  {
    "Property Name": "spark.sql.json.filterPushdown.enabled",
    "Default": "true",
    "Meaning": "When true, enable filter pushdown to JSON datasource.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.jsonGenerator.ignoreNullFields",
    "Default": "true",
    "Meaning": "Whether to ignore null fields when generating JSON objects in JSON data source and JSON functions such as to_json. If false, it generates null for null fields in JSON objects.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.leafNodeDefaultParallelism",
    "Default": "(none)",
    "Meaning": "The default parallelism of Spark SQL leaf nodes that produce data, such as the file scan node, the local data scan node, the range node, etc. The default value of this config is \u0027SparkContext#defaultParallelism\u0027.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.mapKeyDedupPolicy",
    "Default": "EXCEPTION",
    "Meaning": "The policy to deduplicate map keys in builtin function: CreateMap, MapFromArrays, MapFromEntries, StringToMap, MapConcat and TransformKeys. When EXCEPTION, the query fails if duplicated map keys are detected. When LAST_WIN, the map key that is inserted at last takes precedence.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.maven.additionalRemoteRepositories",
    "Default": "https://maven-central.storage-download.googleapis.com/maven2/",
    "Meaning": "A comma-delimited string config of the optional additional remote Maven mirror repositories. This is only used for downloading Hive jars in IsolatedClientLoader if the default Maven Central repo is unreachable.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.maxMetadataStringLength",
    "Default": "100",
    "Meaning": "Maximum number of characters to output for a metadata string. e.g. file location in DataSourceScanExec, every value will be abbreviated if exceed length.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.maxPlanStringLength",
    "Default": "2147483632",
    "Meaning": "Maximum number of characters to output for a plan string. If the plan is longer, further output will be truncated. The default setting always generates a full plan. Set this to a lower value such as 8k if plan strings are taking up too much memory or are causing OutOfMemory errors in the driver or UI processes.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.maxSinglePartitionBytes",
    "Default": "9223372036854775807b",
    "Meaning": "The maximum number of bytes allowed for a single partition. Otherwise, The planner will introduce shuffle to improve parallelism.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.optimizer.collapseProjectAlwaysInline",
    "Default": "false",
    "Meaning": "Whether to always collapse two adjacent projections and inline expressions even if it causes extra duplication.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.dynamicPartitionPruning.enabled",
    "Default": "true",
    "Meaning": "When true, we will generate predicate for partition column when it\u0027s used as join key",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.optimizer.enableCsvExpressionOptimization",
    "Default": "true",
    "Meaning": "Whether to optimize CSV expressions in SQL optimizer. It includes pruning unnecessary columns from from_csv.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.optimizer.enableJsonExpressionOptimization",
    "Default": "true",
    "Meaning": "Whether to optimize JSON expressions in SQL optimizer. It includes pruning unnecessary columns from from_json, simplifying from_json + to_json, to_json + named_struct(from_json.col1, from_json.col2, ....).",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.optimizer.excludedRules",
    "Default": "(none)",
    "Meaning": "Configures a list of rules to be disabled in the optimizer, in which the rules are specified by their rule names and separated by comma. It is not guaranteed that all the rules in this configuration will eventually be excluded, as some rules are necessary for correctness. The optimizer will log the rules that have indeed been excluded.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.applicationSideScanSizeThreshold",
    "Default": "10GB",
    "Meaning": "Byte size threshold of the Bloom filter application side plan\u0027s aggregated scan size. Aggregated scan byte size of the Bloom filter application side needs to be over this value to inject a bloom filter.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.creationSideThreshold",
    "Default": "10MB",
    "Meaning": "Size threshold of the bloom filter creation side plan. Estimated size needs to be under this value to try to inject bloom filter.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.enabled",
    "Default": "true",
    "Meaning": "When true and if one side of a shuffle join has a selective predicate, we attempt to insert a bloom filter in the other side to reduce the amount of shuffle data.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.expectedNumItems",
    "Default": "1000000",
    "Meaning": "The default number of expected items for the runtime bloomfilter",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.maxNumBits",
    "Default": "67108864",
    "Meaning": "The max number of bits to use for the runtime bloom filter",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.maxNumItems",
    "Default": "4000000",
    "Meaning": "The max allowed number of expected items for the runtime bloom filter",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.bloomFilter.numBits",
    "Default": "8388608",
    "Meaning": "The default number of bits to use for the runtime bloom filter",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtime.rowLevelOperationGroupFilter.enabled",
    "Default": "true",
    "Meaning": "Enables runtime group filtering for group-based row-level operations. Data sources that replace groups of data (e.g. files, partitions) may prune entire groups using provided data source filters when planning a row-level operation scan. However, such filtering is limited as not all expressions can be converted into data source filters and some expressions can only be evaluated by Spark (e.g. subqueries). Since rewriting groups is expensive, Spark can execute a query at runtime to find what records match the condition of the row-level operation. The information about matching records will be passed back to the row-level operation scan, allowing data sources to discard groups that don\u0027t have to be rewritten.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtimeFilter.number.threshold",
    "Default": "10",
    "Meaning": "The total number of injected runtime filters (non-DPP) for a single query. This is to prevent driver OOMs with too many Bloom filters.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.optimizer.runtimeFilter.semiJoinReduction.enabled",
    "Default": "false",
    "Meaning": "When true and if one side of a shuffle join has a selective predicate, we attempt to insert a semi join in the other side to reduce the amount of shuffle data.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.orc.aggregatePushdown",
    "Default": "false",
    "Meaning": "If true, aggregates will be pushed down to ORC for optimization. Support MIN, MAX and COUNT as aggregate expression. For MIN/MAX, support boolean, integer, float and date type. For COUNT, support all data types. If statistics is missing from any ORC file footer, exception would be thrown.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.orc.columnarReaderBatchSize",
    "Default": "4096",
    "Meaning": "The number of rows to include in a orc vectorized reader batch. The number should be carefully chosen to minimize overhead and avoid OOMs in reading data.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.orc.columnarWriterBatchSize",
    "Default": "1024",
    "Meaning": "The number of rows to include in a orc vectorized writer batch. The number should be carefully chosen to minimize overhead and avoid OOMs in writing data.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.orc.compression.codec",
    "Default": "snappy",
    "Meaning": "Sets the compression codec used when writing ORC files. If either compression or orc.compress is specified in the table-specific options/properties, the precedence would be compression, orc.compress, spark.sql.orc.compression.codec.Acceptable values include: none, uncompressed, snappy, zlib, lzo, zstd, lz4.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.orc.enableNestedColumnVectorizedReader",
    "Default": "true",
    "Meaning": "Enables vectorized orc decoding for nested column.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.orc.enableVectorizedReader",
    "Default": "true",
    "Meaning": "Enables vectorized orc decoding.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.orc.filterPushdown",
    "Default": "true",
    "Meaning": "When true, enable filter pushdown for ORC files.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.orc.mergeSchema",
    "Default": "false",
    "Meaning": "When true, the Orc data source merges schemas collected from all data files, otherwise the schema is picked from a random data file.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.orderByOrdinal",
    "Default": "true",
    "Meaning": "When true, the ordinal numbers are treated as the position in the select list. When false, the ordinal numbers in order/sort by clause are ignored.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.parquet.aggregatePushdown",
    "Default": "false",
    "Meaning": "If true, aggregates will be pushed down to Parquet for optimization. Support MIN, MAX and COUNT as aggregate expression. For MIN/MAX, support boolean, integer, float and date type. For COUNT, support all data types. If statistics is missing from any Parquet file footer, exception would be thrown.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.binaryAsString",
    "Default": "false",
    "Meaning": "Some other Parquet-producing systems, in particular Impala and older versions of Spark SQL, do not differentiate between binary data and strings when writing out the Parquet schema. This flag tells Spark SQL to interpret binary data as a string to provide compatibility with these systems.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.sql.parquet.columnarReaderBatchSize",
    "Default": "4096",
    "Meaning": "The number of rows to include in a parquet vectorized reader batch. The number should be carefully chosen to minimize overhead and avoid OOMs in reading data.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.parquet.compression.codec",
    "Default": "snappy",
    "Meaning": "Sets the compression codec used when writing Parquet files. If either compression or parquet.compression is specified in the table-specific options/properties, the precedence would be compression, parquet.compression, spark.sql.parquet.compression.codec. Acceptable values include: none, uncompressed, snappy, gzip, lzo, brotli, lz4, lz4raw, lz4_raw, zstd.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.sql.parquet.enableNestedColumnVectorizedReader",
    "Default": "true",
    "Meaning": "Enables vectorized Parquet decoding for nested columns (e.g., struct, list, map). Requires spark.sql.parquet.enableVectorizedReader to be enabled.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.enableVectorizedReader",
    "Default": "true",
    "Meaning": "Enables vectorized parquet decoding.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.parquet.fieldId.read.enabled",
    "Default": "false",
    "Meaning": "Field ID is a native field of the Parquet schema spec. When enabled, Parquet readers will use field IDs (if present) in the requested Spark schema to look up Parquet fields instead of using column names",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.fieldId.read.ignoreMissing",
    "Default": "false",
    "Meaning": "When the Parquet file doesn\u0027t have any field IDs but the Spark read schema is using field IDs to read, we will silently return nulls when this flag is enabled, or error otherwise.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.fieldId.write.enabled",
    "Default": "true",
    "Meaning": "Field ID is a native field of the Parquet schema spec. When enabled, Parquet writers will populate the field Id metadata (if present) in the Spark schema to the Parquet schema.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.filterPushdown",
    "Default": "true",
    "Meaning": "Enables Parquet filter push-down optimization when set to true.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.sql.parquet.inferTimestampNTZ.enabled",
    "Default": "true",
    "Meaning": "When enabled, Parquet timestamp columns with annotation isAdjustedToUTC \u003d false are inferred as TIMESTAMP_NTZ type during schema inference. Otherwise, all the Parquet timestamp columns are inferred as TIMESTAMP_LTZ types. Note that Spark writes the output schema into Parquet\u0027s footer metadata on file writing and leverages it on file reading. Thus this configuration only affects the schema inference on Parquet files which are not written by Spark.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.parquet.int96AsTimestamp",
    "Default": "true",
    "Meaning": "Some Parquet-producing systems, in particular Impala, store Timestamp into INT96. Spark would also store Timestamp as INT96 because we need to avoid precision lost of the nanoseconds field. This flag tells Spark SQL to interpret INT96 data as a timestamp to provide compatibility with these systems.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.int96TimestampConversion",
    "Default": "false",
    "Meaning": "This controls whether timestamp adjustments should be applied to INT96 data when converting to timestamps, for data written by Impala. This is necessary because Impala stores INT96 data with a different timezone offset than Hive \u0026 Spark.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.mergeSchema",
    "Default": "false",
    "Meaning": "When true, the Parquet data source merges schemas collected from all data files, otherwise the schema is picked from the summary file or a random data file if no summary file is available.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.parquet.outputTimestampType",
    "Default": "INT96",
    "Meaning": "Sets which Parquet timestamp type to use when Spark writes data to Parquet files. INT96 is a non-standard but commonly used timestamp type in Parquet. TIMESTAMP_MICROS is a standard timestamp type in Parquet, which stores number of microseconds from the Unix epoch. TIMESTAMP_MILLIS is also standard, but with millisecond precision, which means Spark has to truncate the microsecond portion of its timestamp value.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.recordLevelFilter.enabled",
    "Default": "false",
    "Meaning": "If true, enables Parquet\u0027s native record-level filtering using the pushed down filters. This configuration only has an effect when \u0027spark.sql.parquet.filterPushdown\u0027 is enabled and the vectorized reader is not used. You can ensure the vectorized reader is not used by setting \u0027spark.sql.parquet.enableVectorizedReader\u0027 to false.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.parquet.respectSummaryFiles",
    "Default": "false",
    "Meaning": "When true, we make assumption that all part-files of Parquet are consistent with summary files and we will ignore them when merging schema. Otherwise, if this is false, which is the default, we will merge all part-files. This should be considered as expert-only option, and shouldn\u0027t be enabled before knowing what it means exactly.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.parquet.writeLegacyFormat",
    "Default": "false",
    "Meaning": "If true, data will be written in a way of Spark 1.4 and earlier. For example, decimal values will be written in Apache Parquet\u0027s fixed-length byte array format, which other systems such as Apache Hive and Apache Impala use. If false, the newer format in Parquet will be used. For example, decimals will be written in int-based format. If Parquet output is intended for use with systems that do not support this newer format, set to true.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.sql.parser.quotedRegexColumnNames",
    "Default": "false",
    "Meaning": "When true, quoted Identifiers (using backticks) in SELECT statement are interpreted as regular expressions.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.pivotMaxValues",
    "Default": "10000",
    "Meaning": "When doing a pivot without specifying values for the pivot column this is the maximum number of (distinct) values that will be collected without error.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.sql.pyspark.inferNestedDictAsStruct.enabled",
    "Default": "false",
    "Meaning": "PySpark\u0027s SparkSession.createDataFrame infers the nested dict as a map by default. When it set to true, it infers the nested dict as a struct.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.pyspark.jvmStacktrace.enabled",
    "Default": "false",
    "Meaning": "When true, it shows the JVM stacktrace in the user-facing PySpark exception together with Python stacktrace. By default, it is disabled to hide JVM stacktrace and shows a Python-friendly exception only. Note that this is independent from log level settings.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.pyspark.legacy.inferArrayTypeFromFirstElement.enabled",
    "Default": "false",
    "Meaning": "PySpark\u0027s SparkSession.createDataFrame infers the element type of an array from all values in the array by default. If this config is set to true, it restores the legacy behavior of only inferring the type from the first array element.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.readSideCharPadding",
    "Default": "true",
    "Meaning": "When true, Spark applies string padding when reading CHAR type columns/fields, in addition to the write-side padding. This config is true by default to better enforce CHAR type semantic in cases such as external tables.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.redaction.options.regex",
    "Default": "(?i)url",
    "Meaning": "Regex to decide which keys in a Spark SQL command\u0027s options map contain sensitive information. The values of options whose names that match this regex will be redacted in the explain output. This redaction is applied on top of the global redaction configuration defined by spark.redaction.regex.",
    "Since Version": "2.2.2"
  },
  {
    "Property Name": "spark.sql.redaction.string.regex",
    "Default": "(value of spark.redaction.string.regex)",
    "Meaning": "Regex to decide which parts of strings produced by Spark contain sensitive information. When this regex matches a string part, that string part is replaced by a dummy value. This is currently used to redact the output of SQL explain commands. When this conf is not set, the value from spark.redaction.string.regex is used.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.repl.eagerEval.enabled",
    "Default": "false",
    "Meaning": "Enables eager evaluation or not. When true, the top K rows of Dataset will be displayed if and only if the REPL supports the eager evaluation. Currently, the eager evaluation is supported in PySpark and SparkR. In PySpark, for the notebooks like Jupyter, the HTML table (generated by repr_html) will be returned. For plain Python REPL, the returned outputs are formatted like dataframe.show(). In SparkR, the returned outputs are showed similar to R data.frame would.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.repl.eagerEval.maxNumRows",
    "Default": "20",
    "Meaning": "The max number of rows that are returned by eager evaluation. This only takes effect when spark.sql.repl.eagerEval.enabled is set to true. The valid range of this config is from 0 to (Int.MaxValue - 1), so the invalid config like negative and greater than (Int.MaxValue - 1) will be normalized to 0 and (Int.MaxValue - 1).",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.repl.eagerEval.truncate",
    "Default": "20",
    "Meaning": "The max number of characters for each cell that is returned by eager evaluation. This only takes effect when spark.sql.repl.eagerEval.enabled is set to true.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.session.localRelationCacheThreshold",
    "Default": "67108864",
    "Meaning": "The threshold for the size in bytes of local relations to be cached at the driver side after serialization.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.sql.session.timeZone",
    "Default": "(value of local timezone)",
    "Meaning": "The ID of session local timezone in the format of either region-based zone IDs or zone offsets. Region IDs must have the form \u0027area/city\u0027, such as \u0027America/Los_Angeles\u0027. Zone offsets must be in the format \u0027(+|-)HH\u0027, \u0027(+|-)HH:mm\u0027 or \u0027(+|-)HH:mm:ss\u0027, e.g \u0027-08\u0027, \u0027+01:00\u0027 or \u0027-13:33:33\u0027. Also \u0027UTC\u0027 and \u0027Z\u0027 are supported as aliases of \u0027+00:00\u0027. Other short names are not recommended to use because they can be ambiguous.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.shuffle.partitions",
    "Default": "200",
    "Meaning": "The default number of partitions to use when shuffling data for joins or aggregations. Note: For structured streaming, this configuration cannot be changed between query restarts from the same checkpoint location.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.sql.shuffledHashJoinFactor",
    "Default": "3",
    "Meaning": "The shuffle hash join can be selected if the data size of small side multiplied by this factor is still smaller than the large side.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.sources.bucketing.autoBucketedScan.enabled",
    "Default": "true",
    "Meaning": "When true, decide whether to do bucketed scan on input tables based on query plan automatically. Do not use bucketed scan if 1. query does not have operators to utilize bucketing (e.g. join, group-by, etc), or 2. there\u0027s an exchange operator between these operators and table scan. Note when \u0027spark.sql.sources.bucketing.enabled\u0027 is set to false, this configuration does not take any effect.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.sources.bucketing.enabled",
    "Default": "true",
    "Meaning": "When false, we will treat bucketed table as normal table",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.sources.bucketing.maxBuckets",
    "Default": "100000",
    "Meaning": "The maximum number of buckets allowed.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.sources.default",
    "Default": "parquet",
    "Meaning": "The default data source to use in input/output.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.sql.sources.parallelPartitionDiscovery.threshold",
    "Default": "32",
    "Meaning": "The maximum number of paths allowed for listing files at driver side. If the number of detected paths exceeds this value during partition discovery, it tries to list the files with another Spark distributed job. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.sources.partitionColumnTypeInference.enabled",
    "Default": "true",
    "Meaning": "When true, automatically infer the data types for partitioned columns.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.sources.partitionOverwriteMode",
    "Default": "STATIC",
    "Meaning": "When INSERT OVERWRITE a partitioned data source table, we currently support 2 modes: static and dynamic. In static mode, Spark deletes all the partitions that match the partition specification(e.g. PARTITION(a\u003d1,b)) in the INSERT statement, before overwriting. In dynamic mode, Spark doesn\u0027t delete partitions ahead, and only overwrite those partitions that have data written into it at runtime. By default we use static mode to keep the same behavior of Spark prior to 2.3. Note that this config doesn\u0027t affect Hive serde tables, as they are always overwritten with dynamic mode. This can also be set as an output option for a data source using key partitionOverwriteMode (which takes precedence over this setting), e.g. dataframe.write.option(\"partitionOverwriteMode\", \"dynamic\").save(path).",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.sources.v2.bucketing.enabled",
    "Default": "false",
    "Meaning": "Similar to spark.sql.sources.bucketing.enabled, this config is used to enable bucketing for V2 data sources. When turned on, Spark will recognize the specific distribution reported by a V2 data source through SupportsReportPartitioning, and will try to avoid shuffle if necessary.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.sql.sources.v2.bucketing.partiallyClusteredDistribution.enabled",
    "Default": "false",
    "Meaning": "During a storage-partitioned join, whether to allow input partitions to be partially clustered, when both sides of the join are of KeyGroupedPartitioning. At planning time, Spark will pick the side with less data size based on table statistics, group and replicate them to match the other side. This is an optimization on skew join and can help to reduce data skewness when certain partitions are assigned large amount of data. This config requires both spark.sql.sources.v2.bucketing.enabled and spark.sql.sources.v2.bucketing.pushPartValues.enabled to be enabled",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.sources.v2.bucketing.pushPartValues.enabled",
    "Default": "false",
    "Meaning": "Whether to pushdown common partition values when spark.sql.sources.v2.bucketing.enabled is enabled. When turned on, if both sides of a join are of KeyGroupedPartitioning and if they share compatible partition keys, even if they don\u0027t have the exact same partition values, Spark will calculate a superset of partition values and pushdown that info to scan nodes, which will use empty partitions for the missing partition values on either side. This could help to eliminate unnecessary shuffles",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.statistics.fallBackToHdfs",
    "Default": "false",
    "Meaning": "When true, it will fall back to HDFS if the table statistics are not available from table metadata. This is useful in determining if a table is small enough to use broadcast joins. This flag is effective only for non-partitioned Hive tables. For non-partitioned data source tables, it will be automatically recalculated if table statistics are not available. For partitioned data source and partitioned Hive tables, It is \u0027spark.sql.defaultSizeInBytes\u0027 if table statistics are not available.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.statistics.histogram.enabled",
    "Default": "false",
    "Meaning": "Generates histograms when computing column statistics if enabled. Histograms can provide better estimation accuracy. Currently, Spark only supports equi-height histogram. Note that collecting histograms takes extra cost. For example, collecting column statistics usually takes only one table scan, but generating equi-height histogram will cause an extra table scan.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.statistics.size.autoUpdate.enabled",
    "Default": "false",
    "Meaning": "Enables automatic update for table size once table\u0027s data is changed. Note that if the total number of files of the table is very large, this can be expensive and slow down data change commands.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.storeAssignmentPolicy",
    "Default": "ANSI",
    "Meaning": "When inserting a value into a column with different data type, Spark will perform type coercion. Currently, we support 3 policies for the type coercion rules: ANSI, legacy and strict. With ANSI policy, Spark performs the type coercion as per ANSI SQL. In practice, the behavior is mostly the same as PostgreSQL. It disallows certain unreasonable type conversions such as converting string to int or double to boolean. With legacy policy, Spark allows the type coercion as long as it is a valid Cast, which is very loose. e.g. converting string to int or double to boolean is allowed. It is also the only behavior in Spark 2.x and it is compatible with Hive. With strict policy, Spark doesn\u0027t allow any possible precision loss or data truncation in type coercion, e.g. converting double to int or decimal to double is not allowed.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.checkpointLocation",
    "Default": "(none)",
    "Meaning": "The default location for storing checkpoint data for streaming queries.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.continuous.epochBacklogQueueSize",
    "Default": "10000",
    "Meaning": "The max number of entries to be stored in queue to wait for late epochs. If this parameter is exceeded by the size of the queue, stream will stop with an error.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.disabledV2Writers",
    "Default": "",
    "Meaning": "A comma-separated list of fully qualified data source register class names for which StreamWriteSupport is disabled. Writes to these sources will fall back to the V1 Sinks.",
    "Since Version": "2.3.1"
  },
  {
    "Property Name": "spark.sql.streaming.fileSource.cleaner.numThreads",
    "Default": "1",
    "Meaning": "Number of threads used in the file source completed file cleaner.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.forceDeleteTempCheckpointLocation",
    "Default": "false",
    "Meaning": "When true, enable temporary checkpoint locations force delete.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.metricsEnabled",
    "Default": "false",
    "Meaning": "Whether Dropwizard/Codahale metrics will be reported for active streaming queries.",
    "Since Version": "2.0.2"
  },
  {
    "Property Name": "spark.sql.streaming.multipleWatermarkPolicy",
    "Default": "min",
    "Meaning": "Policy to calculate the global watermark value when there are multiple watermark operators in a streaming query. The default value is \u0027min\u0027 which chooses the minimum watermark reported across multiple operators. Other alternative value is \u0027max\u0027 which chooses the maximum across multiple operators. Note: This configuration cannot be changed between query restarts from the same checkpoint location.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.streaming.noDataMicroBatches.enabled",
    "Default": "true",
    "Meaning": "Whether streaming micro-batch engine will execute batches without data for eager state management for stateful streaming queries.",
    "Since Version": "2.4.1"
  },
  {
    "Property Name": "spark.sql.streaming.numRecentProgressUpdates",
    "Default": "100",
    "Meaning": "The number of progress updates to retain for a streaming query",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "spark.sql.streaming.sessionWindow.merge.sessions.in.local.partition",
    "Default": "false",
    "Meaning": "When true, streaming session window sorts and merge sessions in local partition prior to shuffle. This is to reduce the rows to shuffle, but only beneficial when there\u0027re lots of rows in a batch being assigned to same sessions.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.streaming.stateStore.stateSchemaCheck",
    "Default": "true",
    "Meaning": "When true, Spark will validate the state schema against schema on existing state and fail query if it\u0027s incompatible.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.streaming.stopActiveRunOnRestart",
    "Default": "true",
    "Meaning": "Running multiple runs of the same streaming query concurrently is not supported. If we find a concurrent active run for a streaming query (in the same or different SparkSessions on the same cluster) and this flag is true, we will stop the old streaming query run to start the new one.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.stopTimeout",
    "Default": "0",
    "Meaning": "How long to wait in milliseconds for the streaming execution thread to stop when calling the streaming query\u0027s stop() method. 0 or negative values wait indefinitely.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.thriftServer.interruptOnCancel",
    "Default": "true",
    "Meaning": "When true, all running tasks will be interrupted if one cancels a query. When false, all running tasks will remain until finished.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.sql.thriftServer.queryTimeout",
    "Default": "0ms",
    "Meaning": "Set a query duration timeout in seconds in Thrift Server. If the timeout is set to a positive value, a running query will be cancelled automatically when the timeout is exceeded, otherwise the query continues to run till completion. If timeout values are set for each statement via java.sql.Statement.setQueryTimeout and they are smaller than this configuration value, they take precedence. If you set this timeout and prefer to cancel the queries right away without waiting task to finish, consider enabling spark.sql.thriftServer.interruptOnCancel together.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.thriftserver.scheduler.pool",
    "Default": "(none)",
    "Meaning": "Set a Fair Scheduler pool for a JDBC client session.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.sql.thriftserver.ui.retainedSessions",
    "Default": "200",
    "Meaning": "The number of SQL client sessions kept in the JDBC/ODBC web UI history.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.thriftserver.ui.retainedStatements",
    "Default": "200",
    "Meaning": "The number of SQL statements kept in the JDBC/ODBC web UI history.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.timestampType",
    "Default": "TIMESTAMP_LTZ",
    "Meaning": "Configures the default timestamp type of Spark SQL, including SQL DDL, Cast clause, type literal and the schema inference of data sources. Setting the configuration as TIMESTAMP_NTZ will use TIMESTAMP WITHOUT TIME ZONE as the default type while putting it as TIMESTAMP_LTZ will use TIMESTAMP WITH LOCAL TIME ZONE. Before the 3.4.0 release, Spark only supports the TIMESTAMP WITH LOCAL TIME ZONE type.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.tvf.allowMultipleTableArguments.enabled",
    "Default": "false",
    "Meaning": "When true, allows multiple table arguments for table-valued functions, receiving the cartesian product of all the rows of these tables.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.sql.ui.explainMode",
    "Default": "formatted",
    "Meaning": "Configures the query explain mode used in the Spark SQL UI. The value can be \u0027simple\u0027, \u0027extended\u0027, \u0027codegen\u0027, \u0027cost\u0027, or \u0027formatted\u0027. The default value is \u0027formatted\u0027.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.variable.substitute",
    "Default": "true",
    "Meaning": "This enables substitution using syntax like ${var}, ${system:var}, and ${env:var}.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.sql.cache.serializer",
    "Default": "org.apache.spark.sql.execution.columnar.DefaultCachedBatchSerializer",
    "Meaning": "The name of a class that implements org.apache.spark.sql.columnar.CachedBatchSerializer. It will be used to translate SQL data into a format that can more efficiently be cached. The underlying API is subject to change so use with caution. Multiple classes cannot be specified. The class must have a no-arg constructor.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.catalog.spark_catalog.defaultDatabase",
    "Default": "default",
    "Meaning": "The default database for session catalog.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.sql.event.truncate.length",
    "Default": "2147483647",
    "Meaning": "Threshold of SQL length beyond which it will be truncated before adding to event. Defaults to no truncation. If set to 0, callsite will be logged instead.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.extensions",
    "Default": "(none)",
    "Meaning": "A comma-separated list of classes that implement Function1[SparkSessionExtensions, Unit] used to configure Spark Session extensions. The classes must have a no-args constructor. If multiple extensions are specified, they are applied in the specified order. For the case of rules and planner strategies, they are applied in the specified order. For the case of parsers, the last parser is used and each parser can delegate to its predecessor. For the case of function name conflicts, the last registered function name is used.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.sql.hive.metastore.barrierPrefixes",
    "Default": "",
    "Meaning": "A comma separated list of class prefixes that should explicitly be reloaded for each version of Hive that Spark SQL is communicating with. For example, Hive UDFs that are declared in a prefix that typically would be shared (i.e. org.apache.spark.*).",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.hive.metastore.jars",
    "Default": "builtin",
    "Meaning": "Location of the jars that should be used to instantiate the HiveMetastoreClient. This property can be one of four options: 1. \"builtin\" Use Hive 2.3.9, which is bundled with the Spark assembly when -Phive is enabled. When this option is chosen, spark.sql.hive.metastore.version must be either 2.3.9 or not defined. 2. \"maven\" Use Hive jars of specified version downloaded from Maven repositories. 3. \"path\" Use Hive jars configured by spark.sql.hive.metastore.jars.path in comma separated format. Support both local or remote paths.The provided jars should be the same version as spark.sql.hive.metastore.version. 4. A classpath in the standard format for both Hive and Hadoop. The provided jars should be the same version as spark.sql.hive.metastore.version.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.hive.metastore.jars.path",
    "Default": "",
    "Meaning": "Comma-separated paths of the jars that used to instantiate the HiveMetastoreClient. This configuration is useful only when spark.sql.hive.metastore.jars is set as path. The paths can be any of the following format: 1. file://path/to/jar/foo.jar 2. hdfs://nameservice/path/to/jar/foo.jar 3. /path/to/jar/ (path without URI scheme follow conf fs.defaultFS\u0027s URI schema) 4. [http/https/ftp]://path/to/jar/foo.jar Note that 1, 2, and 3 support wildcard. For example: 1. file://path/to/jar/,file://path2/to/jar//.jar 2. hdfs://nameservice/path/to/jar/,hdfs://nameservice2/path/to/jar//.jar",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.hive.metastore.sharedPrefixes",
    "Default": "com.mysql.jdbc,org.postgresql,com.microsoft.sqlserver,oracle.jdbc",
    "Meaning": "A comma separated list of class prefixes that should be loaded using the classloader that is shared between Spark SQL and a specific version of Hive. An example of classes that should be shared is JDBC drivers that are needed to talk to the metastore. Other classes that need to be shared are those that interact with classes that are already shared. For example, custom appenders that are used by log4j.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.hive.metastore.version",
    "Default": "2.3.9",
    "Meaning": "Version of the Hive metastore. Available options are 0.12.0 through 2.3.9 and 3.0.0 through 3.1.3.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.sql.hive.thriftServer.singleSession",
    "Default": "false",
    "Meaning": "When set to true, Hive Thrift server is running in a single session mode. All the JDBC/ODBC connections share the temporary views, function registries, SQL configuration and the current database.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.sql.hive.version",
    "Default": "2.3.9",
    "Meaning": "The compiled, a.k.a, builtin Hive version of the Spark distribution bundled with. Note that, this a read-only conf and only used to report the built-in hive version. If you want a different metastore client for Spark to call, please refer to spark.sql.hive.metastore.version.",
    "Since Version": "1.1.1"
  },
  {
    "Property Name": "spark.sql.metadataCacheTTLSeconds",
    "Default": "-1000ms",
    "Meaning": "Time-to-live (TTL) value for the metadata caches: partition file metadata cache and session catalog cache. This configuration only has an effect when this value having a positive value (\u003e 0). It also requires setting \u0027spark.sql.catalogImplementation\u0027 to hive, setting \u0027spark.sql.hive.filesourcePartitionFileCacheSize\u0027 \u003e 0 and setting \u0027spark.sql.hive.manageFilesourcePartitions\u0027 to true to be applied to the partition file metadata cache.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.queryExecutionListeners",
    "Default": "(none)",
    "Meaning": "List of class names implementing QueryExecutionListener that will be automatically added to newly created sessions. The classes should have either a no-arg constructor, or a constructor that expects a SparkConf argument.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.sql.sources.disabledJdbcConnProviderList",
    "Default": "",
    "Meaning": "Configures a list of JDBC connection providers, which are disabled. The list contains the name of the JDBC connection providers separated by comma.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.sql.streaming.streamingQueryListeners",
    "Default": "(none)",
    "Meaning": "List of class names implementing StreamingQueryListener that will be automatically added to newly created sessions. The classes should have either a no-arg constructor, or a constructor that expects a SparkConf argument.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.sql.streaming.ui.enabled",
    "Default": "true",
    "Meaning": "Whether to run the Structured Streaming Web UI for the Spark application when the Spark Web UI is enabled.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.ui.retainedProgressUpdates",
    "Default": "100",
    "Meaning": "The number of progress updates to retain for a streaming query for Structured Streaming UI.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.streaming.ui.retainedQueries",
    "Default": "100",
    "Meaning": "The number of inactive queries to retain for Structured Streaming UI.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.sql.ui.retainedExecutions",
    "Default": "1000",
    "Meaning": "Number of executions to retain in the Spark UI.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.sql.warehouse.dir",
    "Default": "(value of $PWD/spark-warehouse)",
    "Meaning": "The default location for managed databases and tables.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.streaming.backpressure.enabled",
    "Default": "false",
    "Meaning": "Enables or disables Spark Streaming\u0027s internal backpressure mechanism (since 1.5). This enables the Spark Streaming to control the receiving rate based on the current batch scheduling delays and processing times so that the system receives only as fast as the system can process. Internally, this dynamically sets the maximum receiving rate of receivers. This rate is upper bounded by the values spark.streaming.receiver.maxRate and spark.streaming.kafka.maxRatePerPartition if they are set (see below).",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.streaming.backpressure.initialRate",
    "Default": "not set",
    "Meaning": "This is the initial maximum receiving rate at which each receiver will receive data for the first batch when the backpressure mechanism is enabled.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.streaming.blockInterval",
    "Default": "200ms",
    "Meaning": "Interval at which data received by Spark Streaming receivers is chunked into blocks of data before storing them in Spark. Minimum recommended - 50 ms. See the performance tuning section in the Spark Streaming programming guide for more details.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.streaming.receiver.maxRate",
    "Default": "not set",
    "Meaning": "Maximum rate (number of records per second) at which each receiver will receive data. Effectively, each stream will consume at most this number of records per second. Setting this configuration to 0 or a negative number will put no limit on the rate. See the deployment guide in the Spark Streaming programming guide for mode details.",
    "Since Version": "1.0.2"
  },
  {
    "Property Name": "spark.streaming.receiver.writeAheadLog.enable",
    "Default": "false",
    "Meaning": "Enable write-ahead logs for receivers. All the input data received through receivers will be saved to write-ahead logs that will allow it to be recovered after driver failures. See the deployment guide in the Spark Streaming programming guide for more details.",
    "Since Version": "1.2.1"
  },
  {
    "Property Name": "spark.streaming.unpersist",
    "Default": "true",
    "Meaning": "Force RDDs generated and persisted by Spark Streaming to be automatically unpersisted from Spark\u0027s memory. The raw input data received by Spark Streaming is also automatically cleared. Setting this to false will allow the raw data and persisted RDDs to be accessible outside the streaming application as they will not be cleared automatically. But it comes at the cost of higher memory usage in Spark.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.streaming.stopGracefullyOnShutdown",
    "Default": "false",
    "Meaning": "If true, Spark shuts down the StreamingContext gracefully on JVM shutdown rather than immediately.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.streaming.kafka.maxRatePerPartition",
    "Default": "not set",
    "Meaning": "Maximum rate (number of records per second) at which data will be read from each Kafka partition when using the new Kafka direct stream API. See the Kafka Integration guide for more details.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.streaming.kafka.minRatePerPartition",
    "Default": "1",
    "Meaning": "Minimum rate (number of records per second) at which data will be read from each Kafka partition when using the new Kafka direct stream API.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.streaming.ui.retainedBatches",
    "Default": "1000",
    "Meaning": "How many batches the Spark Streaming UI and status APIs remember before garbage collecting.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.streaming.driver.writeAheadLog.closeFileAfterWrite",
    "Default": "false",
    "Meaning": "Whether to close the file after writing a write-ahead log record on the driver. Set this to \u0027true\u0027 when you want to use S3 (or any file system that does not support flushing) for the metadata WAL on the driver.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.streaming.receiver.writeAheadLog.closeFileAfterWrite",
    "Default": "false",
    "Meaning": "Whether to close the file after writing a write-ahead log record on the receivers. Set this to \u0027true\u0027 when you want to use S3 (or any file system that does not support flushing) for the data WAL on the receivers.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.r.numRBackendThreads",
    "Default": "2",
    "Meaning": "Number of threads used by RBackend to handle RPC calls from SparkR package.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.r.command",
    "Default": "Rscript",
    "Meaning": "Executable for executing R scripts in cluster modes for both driver and workers.",
    "Since Version": "1.5.3"
  },
  {
    "Property Name": "spark.r.driver.command",
    "Default": "spark.r.command",
    "Meaning": "Executable for executing R scripts in client modes for driver. Ignored in cluster modes.",
    "Since Version": "1.5.3"
  },
  {
    "Property Name": "spark.r.shell.command",
    "Default": "R",
    "Meaning": "Executable for executing sparkR shell in client modes for driver. Ignored in cluster modes. It is the same as environment variable SPARKR_DRIVER_R, but take precedence over it. spark.r.shell.command is used for sparkR shell while spark.r.driver.command is used for running R script.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.r.backendConnectionTimeout",
    "Default": "6000",
    "Meaning": "Connection timeout set by R process on its connection to RBackend in seconds.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.r.heartBeatInterval",
    "Default": "100",
    "Meaning": "Interval for heartbeats sent from SparkR backend to R process to prevent connection timeout.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.graphx.pregel.checkpointInterval",
    "Default": "-1",
    "Meaning": "Checkpoint interval for graph and message in Pregel. It used to avoid stackOverflowError due to long lineage chains after lots of iterations. The checkpoint is disabled by default.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.deploy.recoveryMode",
    "Default": "NONE",
    "Meaning": "The recovery mode setting to recover submitted Spark jobs with cluster mode when it failed and relaunches. This is only applicable for cluster mode when running with Standalone or Mesos.",
    "Since Version": "0.8.1"
  },
  {
    "Property Name": "spark.deploy.zookeeper.url",
    "Default": "None",
    "Meaning": "When `spark.deploy.recoveryMode` is set to ZOOKEEPER, this configuration is used to set the zookeeper URL to connect to.",
    "Since Version": "0.8.1"
  },
  {
    "Property Name": "spark.deploy.zookeeper.dir",
    "Default": "None",
    "Meaning": "When `spark.deploy.recoveryMode` is set to ZOOKEEPER, this configuration is used to set the zookeeper directory to store recovery state.",
    "Since Version": "0.8.1"
  },
  {
    "Property Name": "spark.shuffle.push.server.mergedShuffleFileManagerImpl",
    "Default": "org.apache.spark.network.shuffle. NoOpMergedShuffleFileManager",
    "Meaning": "Class name of the implementation of MergedShuffleFileManager that manages push-based shuffle. This acts as a server side config to disable or enable push-based shuffle. By default, push-based shuffle is disabled at the server side. To enable push-based shuffle on the server side, set this config to org.apache.spark.network.shuffle.RemoteBlockPushResolver",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.server.minChunkSizeInMergedShuffleFile",
    "Default": "2m",
    "Meaning": "The minimum size of a chunk when dividing a merged shuffle file into multiple chunks during push-based shuffle. A merged shuffle file consists of multiple small shuffle blocks. Fetching the complete merged shuffle file in a single disk I/O increases the memory requirements for both the clients and the external shuffle services. Instead, the external shuffle service serves the merged file in MB-sized chunks. This configuration controls how big a chunk can get. A corresponding index file for each merged shuffle file will be generated indicating chunk boundaries. Setting this too high would increase the memory requirements on both the clients and the external shuffle service. Setting this too low would increase the overall number of RPC requests to external shuffle service unnecessarily.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.server.mergedIndexCacheSize",
    "Default": "100m",
    "Meaning": "The maximum size of cache in memory which could be used in push-based shuffle for storing merged index files. This cache is in addition to the one configured via spark.shuffle.service.index.cache.size.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.enabled",
    "Default": "false",
    "Meaning": "Set to true to enable push-based shuffle on the client side and works in conjunction with the server side flag spark.shuffle.push.server.mergedShuffleFileManagerImpl.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.finalize.timeout",
    "Default": "10s",
    "Meaning": "The amount of time driver waits in seconds, after all mappers have finished for a given shuffle map stage, before it sends merge finalize requests to remote external shuffle services. This gives the external shuffle services extra time to merge blocks. Setting this too long could potentially lead to performance regression.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.maxRetainedMergerLocations",
    "Default": "500",
    "Meaning": "Maximum number of merger locations cached for push-based shuffle. Currently, merger locations are hosts of external shuffle services responsible for handling pushed blocks, merging them and serving merged blocks for later shuffle fetch.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.mergersMinThresholdRatio",
    "Default": "0.05",
    "Meaning": "Ratio used to compute the minimum number of shuffle merger locations required for a stage based on the number of partitions for the reducer stage. For example, a reduce stage which has 100 partitions and uses the default value 0.05 requires at least 5 unique merger locations to enable push-based shuffle.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.mergersMinStaticThreshold",
    "Default": "5",
    "Meaning": "The static threshold for number of shuffle push merger locations should be available in order to enable push-based shuffle for a stage. Note this config works in conjunction with spark.shuffle.push.mergersMinThresholdRatio. Maximum of spark.shuffle.push.mergersMinStaticThreshold and spark.shuffle.push.mergersMinThresholdRatio ratio number of mergers needed to enable push-based shuffle for a stage. For example: with 1000 partitions for the child stage with spark.shuffle.push.mergersMinStaticThreshold as 5 and spark.shuffle.push.mergersMinThresholdRatio set to 0.05, we would need at least 50 mergers to enable push-based shuffle for that stage.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.numPushThreads",
    "Default": "(none)",
    "Meaning": "Specify the number of threads in the block pusher pool. These threads assist in creating connections and pushing blocks to remote external shuffle services. By default, the threadpool size is equal to the number of spark executor cores.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.maxBlockSizeToPush",
    "Default": "1m",
    "Meaning": "The max size of an individual block to push to the remote external shuffle services. Blocks larger than this threshold are not pushed to be merged remotely. These shuffle blocks will be fetched in the original manner. Setting this too high would result in more blocks to be pushed to remote external shuffle services but those are already efficiently fetched with the existing mechanisms resulting in additional overhead of pushing the large blocks to remote external shuffle services. It is recommended to set spark.shuffle.push.maxBlockSizeToPush lesser than spark.shuffle.push.maxBlockBatchSize config\u0027s value. Setting this too low would result in lesser number of blocks getting merged and directly fetched from mapper external shuffle service results in higher small random reads affecting overall disk I/O performance.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.maxBlockBatchSize",
    "Default": "3m",
    "Meaning": "The max size of a batch of shuffle blocks to be grouped into a single push request. Default is set to 3m in order to keep it slightly higher than spark.storage.memoryMapThreshold default which is 2m as it is very likely that each batch of block gets memory mapped which incurs higher overhead.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.shuffle.push.merge.finalizeThreads",
    "Default": "8",
    "Meaning": "Number of threads used by driver to finalize shuffle merge. Since it could potentially take seconds for a large shuffle to finalize, having multiple threads helps driver to handle concurrent shuffle merge finalize requests when push-based shuffle is enabled.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.shuffle.push.minShuffleSizeToWait",
    "Default": "500m",
    "Meaning": "Driver will wait for merge finalization to complete only if total shuffle data size is more than this threshold. If total shuffle size is less, driver will immediately finalize the shuffle output.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.shuffle.push.minCompletedPushRatio",
    "Default": "1.0",
    "Meaning": "Fraction of minimum map partitions that should be push complete before driver starts shuffle merge finalization during push based shuffle.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.yarn.shuffle.server.recovery.disabled",
    "Default": "false",
    "Meaning": "Set to true for applications that have higher security requirements and prefer that their secret is not saved in the db. The shuffle data of such applications wll not be recovered after the External Shuffle Service restarts.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.authenticate",
    "Default": "false",
    "Meaning": "Whether Spark authenticates its internal connections.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.authenticate.secret",
    "Default": "None",
    "Meaning": "The secret key used authentication. See above for when this configuration should be set.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.authenticate.secret.file",
    "Default": "None",
    "Meaning": "Path pointing to the secret key to use for securing connections. Ensure that the contents of the file have been securely generated. This file is loaded on both the driver and the executors unless other settings override this (see below).",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.authenticate.secret.driver.file",
    "Default": "The value of spark.authenticate.secret.file",
    "Meaning": "When specified, overrides the location that the Spark driver reads to load the secret. Useful when in client mode, when the location of the secret file may differ in the pod versus the node the driver is running in. When this is specified, spark.authenticate.secret.executor.file must be specified so that the driver and the executors can both use files to load the secret key. Ensure that the contents of the file on the driver is identical to the contents of the file on the executors.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.authenticate.secret.executor.file",
    "Default": "The value of spark.authenticate.secret.file",
    "Meaning": "When specified, overrides the location that the Spark executors read to load the secret. Useful in client mode, when the location of the secret file may differ in the pod versus the node the driver is running in. When this is specified, spark.authenticate.secret.driver.file must be specified so that the driver and the executors can both use files to load the secret key. Ensure that the contents of the file on the driver is identical to the contents of the file on the executors.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.network.crypto.enabled",
    "Default": "false",
    "Meaning": "Enable AES-based RPC encryption, including the new authentication protocol added in 2.2.0.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.network.crypto.cipher",
    "Default": "AES/CTR/NoPadding",
    "Meaning": "Cipher mode to use. Defaults \"AES/CTR/NoPadding\" for backward compatibility, which is not authenticated. Recommended to use \"AES/GCM/NoPadding\", which is an authenticated encryption mode.",
    "Since Version": "4.0.0, 3.5.2, 3.4.4"
  },
  {
    "Property Name": "spark.network.crypto.authEngineVersion",
    "Default": "1",
    "Meaning": "Version of AES-based RPC encryption to use. Valid versions are 1 or 2. Version 2 is recommended.",
    "Since Version": "3.4.3, 3.5.2"
  },
  {
    "Property Name": "spark.network.crypto.config.*",
    "Default": "None",
    "Meaning": "Configuration values for the commons-crypto library, such as which cipher implementations to use. The config name should be the name of commons-crypto configuration without the commons.crypto prefix.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.network.crypto.saslFallback",
    "Default": "true",
    "Meaning": "Whether to fall back to SASL authentication if authentication fails using Spark\u0027s internal mechanism. This is useful when the application is connecting to old shuffle services that do not support the internal Spark authentication protocol. On the shuffle service side, disabling this feature will block older clients from authenticating.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.authenticate.enableSaslEncryption",
    "Default": "false",
    "Meaning": "Enable SASL-based encrypted communication.",
    "Since Version": "2.2.0"
  },
  {
    "Property Name": "spark.network.sasl.serverAlwaysEncrypt",
    "Default": "false",
    "Meaning": "Disable unencrypted connections for ports using SASL authentication. This will deny connections from clients that have authentication enabled, but do not request SASL-based encryption.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.io.encryption.enabled",
    "Default": "false",
    "Meaning": "Enable local disk I/O encryption. Currently supported by all modes except Mesos. It\u0027s strongly recommended that RPC encryption be enabled when using this feature.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.io.encryption.keySizeBits",
    "Default": "128",
    "Meaning": "IO encryption key size in bits. Supported values are 128, 192 and 256.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.io.encryption.keygen.algorithm",
    "Default": "HmacSHA1",
    "Meaning": "The algorithm to use when generating the IO encryption key. The supported algorithms are described in the KeyGenerator section of the Java Cryptography Architecture Standard Algorithm Name Documentation.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.io.encryption.commons.config.*",
    "Default": "None",
    "Meaning": "Configuration values for the commons-crypto library, such as which cipher implementations to use. The config name should be the name of commons-crypto configuration without the commons.crypto prefix.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.ui.allowFramingFrom",
    "Default": "SAMEORIGIN",
    "Meaning": "Allow framing for a specific named URI via X-Frame-Options. By default, allow only from the same origin.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.ui.filters",
    "Default": "None",
    "Meaning": "See the Spark UI configuration for how to configure filters.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.acls.enable",
    "Default": "false",
    "Meaning": "Whether UI ACLs should be enabled. If enabled, this checks to see if the user has access permissions to view or modify the application. Note this requires the user to be authenticated, so if no authentication filter is installed, this option does not do anything.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.admin.acls",
    "Default": "None",
    "Meaning": "Comma-separated list of users that have view and modify access to the Spark application.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.admin.acls.groups",
    "Default": "None",
    "Meaning": "Comma-separated list of groups that have view and modify access to the Spark application.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.modify.acls",
    "Default": "None",
    "Meaning": "Comma-separated list of users that have modify access to the Spark application.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.modify.acls.groups",
    "Default": "None",
    "Meaning": "Comma-separated list of groups that have modify access to the Spark application.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.ui.view.acls",
    "Default": "None",
    "Meaning": "Comma-separated list of users that have view access to the Spark application.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.ui.view.acls.groups",
    "Default": "None",
    "Meaning": "Comma-separated list of groups that have view access to the Spark application.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.user.groups.mapping",
    "Default": "org.apache.spark.security.ShellBasedGroupsMappingProvider",
    "Meaning": "The list of groups for a user is determined by a group mapping service defined by the trait org.apache.spark.security.GroupMappingServiceProvider, which can be configured by this property. By default, a Unix shell-based implementation is used, which collects this information from the host OS. Note: This implementation supports only Unix/Linux-based environments. Windows environment is currently not supported. However, a new platform/protocol can be supported by implementing the trait mentioned above.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.history.ui.acls.enable",
    "Default": "false",
    "Meaning": "Specifies whether ACLs should be checked to authorize users viewing the applications in the history server. If enabled, access control checks are performed regardless of what the individual applications had set for spark.ui.acls.enable. The application owner will always have authorization to view their own application and any users specified via spark.ui.view.acls and groups specified via spark.ui.view.acls.groups when the application was run will also have authorization to view that application. If disabled, no access control checks are made for any application UIs available through the history server.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.history.ui.admin.acls",
    "Default": "None",
    "Meaning": "Comma separated list of users that have view access to all the Spark applications in history server.",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "spark.history.ui.admin.acls.groups",
    "Default": "None",
    "Meaning": "Comma separated list of groups that have view access to all the Spark applications in history server.",
    "Since Version": "2.1.1"
  },
  {
    "Property Name": "${ns}.enabled",
    "Default": "false",
    "Meaning": "Enables SSL. When enabled, ${ns}.ssl.protocol is required."
  },
  {
    "Property Name": "${ns}.port",
    "Default": "None",
    "Meaning": "The port where the SSL service will listen on. The port must be defined within a specific namespace configuration. The default namespace is ignored when reading this configuration. When not set, the SSL port will be derived from the non-SSL port for the same service. A value of \"0\" will make the service bind to an ephemeral port."
  },
  {
    "Property Name": "${ns}.enabledAlgorithms",
    "Default": "None",
    "Meaning": "A comma-separated list of ciphers. The specified ciphers must be supported by JVM. The reference list of protocols can be found in the \"JSSE Cipher Suite Names\" section of the Java security guide. The list for Java 8 can be found at this page. Note: If not set, the default cipher suite for the JRE will be used."
  },
  {
    "Property Name": "${ns}.keyPassword",
    "Default": "None",
    "Meaning": "The password to the private key in the key store."
  },
  {
    "Property Name": "${ns}.keyStore",
    "Default": "None",
    "Meaning": "Path to the key store file. The path can be absolute or relative to the directory in which the process is started."
  },
  {
    "Property Name": "${ns}.keyStorePassword",
    "Default": "None",
    "Meaning": "Password to the key store."
  },
  {
    "Property Name": "${ns}.keyStoreType",
    "Default": "JKS",
    "Meaning": "The type of the key store."
  },
  {
    "Property Name": "${ns}.protocol",
    "Default": "None",
    "Meaning": "TLS protocol to use. The protocol must be supported by JVM. The reference list of protocols can be found in the \"Additional JSSE Standard Names\" section of the Java security guide. For Java 8, the list can be found at this page."
  },
  {
    "Property Name": "${ns}.needClientAuth",
    "Default": "false",
    "Meaning": "Whether to require client authentication."
  },
  {
    "Property Name": "${ns}.trustStore",
    "Default": "None",
    "Meaning": "Path to the trust store file. The path can be absolute or relative to the directory in which the process is started."
  },
  {
    "Property Name": "${ns}.trustStorePassword",
    "Default": "None",
    "Meaning": "Password for the trust store."
  },
  {
    "Property Name": "${ns}.trustStoreType",
    "Default": "JKS",
    "Meaning": "The type of the trust store."
  },
  {
    "Property Name": "spark.ui.xXssProtection",
    "Default": "1; mode\u003dblock",
    "Meaning": "Value for HTTP X-XSS-Protection response header. You can choose appropriate value from below: 0 (Disables XSS filtering) 1 (Enables XSS filtering. If a cross-site scripting attack is detected, the browser will sanitize the page.) 1; mode\u003dblock (Enables XSS filtering. The browser will prevent rendering of the page if an attack is detected.)",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.ui.xContentTypeOptions.enabled",
    "Default": "true",
    "Meaning": "When enabled, X-Content-Type-Options HTTP response header will be set to \"nosniff\".",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.ui.strictTransportSecurity",
    "Default": "None",
    "Meaning": "Value for HTTP Strict Transport Security (HSTS) Response Header. You can choose appropriate value from below and set expire-time accordingly. This option is only used when SSL/TLS is enabled. max-age\u003d\u003cexpire-time\u003e max-age\u003d\u003cexpire-time\u003e; includeSubDomains max-age\u003d\u003cexpire-time\u003e; preload",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.security.credentials.${service}.enabled",
    "Default": "true",
    "Meaning": "Controls whether to obtain credentials for services when security is enabled. By default, credentials for all supported services are retrieved when those services are configured, but it\u0027s possible to disable that behavior if it somehow conflicts with the application being run.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kerberos.access.hadoopFileSystems",
    "Default": "(none)",
    "Meaning": "A comma-separated list of secure Hadoop filesystems your Spark application is going to access. For example, spark.kerberos.access.hadoopFileSystems\u003dhdfs://nn1.com:8032,hdfs://nn2.com:8032, webhdfs://nn3.com:50070. The Spark application must have access to the filesystems listed and Kerberos must be properly configured to be able to access them (either in the same realm or in a trusted realm). Spark acquires security tokens for each of the filesystems so that the Spark application can access those remote Hadoop filesystems.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.provider",
    "Default": "org.apache.spark.deploy.history.FsHistoryProvider",
    "Meaning": "Name of the class implementing the application history backend. Currently there is only one implementation, provided by Spark, which looks for application logs stored in the file system.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.history.fs.logDirectory",
    "Default": "file:/tmp/spark-events",
    "Meaning": "For the filesystem history provider, the URL to the directory containing application event logs to load. This can be a local file:// path, an HDFS path hdfs://namenode/shared/spark-logs or that of an alternative filesystem supported by the Hadoop APIs.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.history.fs.update.interval",
    "Default": "10s",
    "Meaning": "The period at which the filesystem history provider checks for new or updated logs in the log directory. A shorter interval detects new applications faster, at the expense of more server load re-reading updated applications. As soon as an update has completed, listings of the completed and incomplete applications will reflect the changes.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.history.retainedApplications",
    "Default": "50",
    "Meaning": "The number of applications to retain UI data for in the cache. If this cap is exceeded, then the oldest applications will be removed from the cache. If an application is not in the cache, it will have to be loaded from disk if it is accessed from the UI.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.history.ui.maxApplications",
    "Default": "Int.MaxValue",
    "Meaning": "The number of applications to display on the history summary page. Application UIs are still available by accessing their URLs directly even if they are not displayed on the history summary page.",
    "Since Version": "2.0.1"
  },
  {
    "Property Name": "spark.history.ui.port",
    "Default": "18080",
    "Meaning": "The port to which the web interface of the history server binds.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.history.kerberos.enabled",
    "Default": "false",
    "Meaning": "Indicates whether the history server should use kerberos to login. This is required if the history server is accessing HDFS files on a secure Hadoop cluster.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.history.kerberos.principal",
    "Default": "(none)",
    "Meaning": "When spark.history.kerberos.enabled\u003dtrue, specifies kerberos principal name for the History Server.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.history.kerberos.keytab",
    "Default": "(none)",
    "Meaning": "When spark.history.kerberos.enabled\u003dtrue, specifies location of the kerberos keytab file for the History Server.",
    "Since Version": "1.0.1"
  },
  {
    "Property Name": "spark.history.fs.cleaner.enabled",
    "Default": "false",
    "Meaning": "Specifies whether the History Server should periodically clean up event logs from storage.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.history.fs.cleaner.interval",
    "Default": "1d",
    "Meaning": "When spark.history.fs.cleaner.enabled\u003dtrue, specifies how often the filesystem job history cleaner checks for files to delete. Files are deleted if at least one of two conditions holds. First, they\u0027re deleted if they\u0027re older than spark.history.fs.cleaner.maxAge. They are also deleted if the number of files is more than spark.history.fs.cleaner.maxNum, Spark tries to clean up the completed attempts from the applications based on the order of their oldest attempt time.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.history.fs.cleaner.maxAge",
    "Default": "7d",
    "Meaning": "When spark.history.fs.cleaner.enabled\u003dtrue, job history files older than this will be deleted when the filesystem history cleaner runs.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.history.fs.cleaner.maxNum",
    "Default": "Int.MaxValue",
    "Meaning": "When spark.history.fs.cleaner.enabled\u003dtrue, specifies the maximum number of files in the event log directory. Spark tries to clean up the completed attempt logs to maintain the log directory under this limit. This should be smaller than the underlying file system limit like `dfs.namenode.fs-limits.max-directory-items` in HDFS.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.fs.endEventReparseChunkSize",
    "Default": "1m",
    "Meaning": "How many bytes to parse at the end of log files looking for the end event. This is used to speed up generation of application listings by skipping unnecessary parts of event log files. It can be disabled by setting this config to 0.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.history.fs.inProgressOptimization.enabled",
    "Default": "true",
    "Meaning": "Enable optimized handling of in-progress logs. This option may leave finished applications that fail to rename their event logs listed as in-progress.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.history.fs.driverlog.cleaner.enabled",
    "Default": "spark.history.fs.cleaner.enabled",
    "Meaning": "Specifies whether the History Server should periodically clean up driver logs from storage.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.fs.driverlog.cleaner.interval",
    "Default": "spark.history.fs.cleaner.interval",
    "Meaning": "When spark.history.fs.driverlog.cleaner.enabled\u003dtrue, specifies how often the filesystem driver log cleaner checks for files to delete. Files are only deleted if they are older than spark.history.fs.driverlog.cleaner.maxAge",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.fs.driverlog.cleaner.maxAge",
    "Default": "spark.history.fs.cleaner.maxAge",
    "Meaning": "When spark.history.fs.driverlog.cleaner.enabled\u003dtrue, driver log files older than this will be deleted when the driver log cleaner runs.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.fs.numReplayThreads",
    "Default": "25% of available cores",
    "Meaning": "Number of threads that will be used by history server to process event logs.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.history.store.maxDiskUsage",
    "Default": "10g",
    "Meaning": "Maximum disk usage for the local directory where the cache application history information are stored.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.history.store.path",
    "Default": "(none)",
    "Meaning": "Local directory where to cache application history data. If set, the history server will store application data on disk instead of keeping it in memory. The data written to disk will be re-used in the event of a history server restart.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.history.store.serializer",
    "Default": "JSON",
    "Meaning": "Serializer for writing/reading in-memory UI objects to/from disk-based KV Store; JSON or PROTOBUF. JSON serializer is the only choice before Spark 3.4.0, thus it is the default value. PROTOBUF serializer is fast and compact, compared to the JSON serializer.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.history.custom.executor.log.url",
    "Default": "(none)",
    "Meaning": "Specifies custom spark executor log URL for supporting external log service instead of using cluster managers\u0027 application log URLs in the history server. Spark will support some path variables via patterns which can vary on cluster manager. Please check the documentation for your cluster manager to see which patterns are supported, if any. This configuration has no effect on a live application, it only affects the history server. For now, only YARN mode supports this configuration",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.custom.executor.log.url.applyIncompleteApplication",
    "Default": "true",
    "Meaning": "Specifies whether to apply custom spark executor log URL to incomplete applications as well. If executor logs for running applications should be provided as origin log URLs, set this to `false`. Please note that incomplete applications may include applications which didn\u0027t shutdown gracefully. Even this is set to `true`, this configuration has no effect on a live application, it only affects the history server.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.fs.eventLog.rolling.maxFilesToRetain",
    "Default": "Int.MaxValue",
    "Meaning": "The maximum number of event log files which will be retained as non-compacted. By default, all event log files will be retained. The lowest value is 1 for technical reason. Please read the section of \"Applying compaction of old event log files\" for more details.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.history.store.hybridStore.enabled",
    "Default": "false",
    "Meaning": "Whether to use HybridStore as the store when parsing event logs. HybridStore will first write data to an in-memory store and having a background thread that dumps data to a disk store after the writing to in-memory store is completed.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.history.store.hybridStore.maxMemoryUsage",
    "Default": "2g",
    "Meaning": "Maximum memory space that can be used to create HybridStore. The HybridStore co-uses the heap memory, so the heap memory should be increased through the memory option for SHS if the HybridStore is enabled.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.history.store.hybridStore.diskBackend",
    "Default": "ROCKSDB",
    "Meaning": "Specifies a disk-based store used in hybrid store; LEVELDB or ROCKSDB.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.history.fs.update.batchSize",
    "Default": "Int.MaxValue",
    "Meaning": "Specifies the batch size for updating new eventlog files. This controls each scan process to be completed within a reasonable time, and such prevent the initial scan from running too long and blocking new eventlog files to be scanned in time in large environments.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.yarn.am.memory",
    "Default": "512m",
    "Meaning": "Amount of memory to use for the YARN Application Master in client mode, in the same format as JVM memory strings (e.g. 512m, 2g). In cluster mode, use spark.driver.memory instead. Use lower-case suffixes, e.g. k, m, g, t, and p, for kibi-, mebi-, gibi-, tebi-, and pebibytes, respectively.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.yarn.am.resource.{resource-type}.amount",
    "Default": "(none)",
    "Meaning": "Amount of resource to use for the YARN Application Master in client mode. In cluster mode, use spark.yarn.driver.resource.\u003cresource-type\u003e.amount instead. Please note that this feature can be used only with YARN 3.0+ For reference, see YARN Resource Model documentation: https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/ResourceModel.html Example: To request GPU resources from YARN, use: spark.yarn.am.resource.yarn.io/gpu.amount",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.applicationType",
    "Default": "SPARK",
    "Meaning": "Defines more specific application types, e.g. SPARK, SPARK-SQL, SPARK-STREAMING, SPARK-MLLIB and SPARK-GRAPH. Please be careful not to exceed 20 characters.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.yarn.driver.resource.{resource-type}.amount",
    "Default": "(none)",
    "Meaning": "Amount of resource to use for the YARN Application Master in cluster mode. Please note that this feature can be used only with YARN 3.0+ For reference, see YARN Resource Model documentation: https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/ResourceModel.html Example: To request GPU resources from YARN, use: spark.yarn.driver.resource.yarn.io/gpu.amount",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.executor.resource.{resource-type}.amount",
    "Default": "(none)",
    "Meaning": "Amount of resource to use per executor process. Please note that this feature can be used only with YARN 3.0+ For reference, see YARN Resource Model documentation: https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/ResourceModel.html Example: To request GPU resources from YARN, use: spark.yarn.executor.resource.yarn.io/gpu.amount",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.resourceGpuDeviceName",
    "Default": "yarn.io/gpu",
    "Meaning": "Specify the mapping of the Spark resource type of gpu to the YARN resource representing a GPU. By default YARN uses yarn.io/gpu but if YARN has been configured with a custom resource type, this allows remapping it. Applies when using the spark.{driver/executor}.resource.gpu.* configs.",
    "Since Version": "3.2.1"
  },
  {
    "Property Name": "spark.yarn.resourceFpgaDeviceName",
    "Default": "yarn.io/fpga",
    "Meaning": "Specify the mapping of the Spark resource type of fpga to the YARN resource representing a FPGA. By default YARN uses yarn.io/fpga but if YARN has been configured with a custom resource type, this allows remapping it. Applies when using the spark.{driver/executor}.resource.fpga.* configs.",
    "Since Version": "3.2.1"
  },
  {
    "Property Name": "spark.yarn.am.cores",
    "Default": "1",
    "Meaning": "Number of cores to use for the YARN Application Master in client mode. In cluster mode, use spark.driver.cores instead.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.yarn.am.waitTime",
    "Default": "100s",
    "Meaning": "Only used in cluster mode. Time for the YARN Application Master to wait for the SparkContext to be initialized.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.yarn.submit.file.replication",
    "Default": "The default HDFS replication (usually 3)",
    "Meaning": "HDFS replication level for the files uploaded into HDFS for the application. These include things like the Spark jar, the app jar, and any distributed cache files/archives.",
    "Since Version": "0.8.1"
  },
  {
    "Property Name": "spark.yarn.stagingDir",
    "Default": "Current user\u0027s home directory in the filesystem",
    "Meaning": "Staging directory used while submitting applications.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.yarn.preserve.staging.files",
    "Default": "false",
    "Meaning": "Set to true to preserve the staged files (Spark jar, app jar, distributed cache files) at the end of the job rather than delete them.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.yarn.scheduler.heartbeat.interval-ms",
    "Default": "3000",
    "Meaning": "The interval in ms in which the Spark application master heartbeats into the YARN ResourceManager. The value is capped at half the value of YARN\u0027s configuration for the expiry interval, i.e. yarn.am.liveness-monitor.expiry-interval-ms.",
    "Since Version": "0.8.1"
  },
  {
    "Property Name": "spark.yarn.scheduler.initial-allocation.interval",
    "Default": "200ms",
    "Meaning": "The initial interval in which the Spark application master eagerly heartbeats to the YARN ResourceManager when there are pending container allocation requests. It should be no larger than spark.yarn.scheduler.heartbeat.interval-ms. The allocation interval will doubled on successive eager heartbeats if pending containers still exist, until spark.yarn.scheduler.heartbeat.interval-ms is reached.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.yarn.historyServer.address",
    "Default": "(none)",
    "Meaning": "The address of the Spark history server, e.g. host.com:18080. The address should not contain a scheme (http://). Defaults to not being set since the history server is an optional service. This address is given to the YARN ResourceManager when the Spark application finishes to link the application from the ResourceManager UI to the Spark history server UI. For this property, YARN properties can be used as variables, and these are substituted by Spark at runtime. For example, if the Spark history server runs on the same node as the YARN ResourceManager, it can be set to ${hadoopconf-yarn.resourcemanager.hostname}:18080.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.yarn.dist.archives",
    "Default": "(none)",
    "Meaning": "Comma separated list of archives to be extracted into the working directory of each executor.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.yarn.dist.files",
    "Default": "(none)",
    "Meaning": "Comma-separated list of files to be placed in the working directory of each executor.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.yarn.dist.jars",
    "Default": "(none)",
    "Meaning": "Comma-separated list of jars to be placed in the working directory of each executor.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.yarn.dist.forceDownloadSchemes",
    "Default": "(none)",
    "Meaning": "Comma-separated list of schemes for which resources will be downloaded to the local disk prior to being added to YARN\u0027s distributed cache. For use in cases where the YARN service does not support schemes that are supported by Spark, like http, https and ftp, or jars required to be in the local YARN client\u0027s classpath. Wildcard \u0027*\u0027 is denoted to download resources for all the schemes.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.executor.instances",
    "Default": "2",
    "Meaning": "The number of executors for static allocation. With spark.dynamicAllocation.enabled, the initial set of executors will be at least this large.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.yarn.am.memoryOverhead",
    "Default": "AM memory * 0.10, with minimum of 384",
    "Meaning": "Same as spark.driver.memoryOverhead, but for the YARN Application Master in client mode.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.yarn.queue",
    "Default": "default",
    "Meaning": "The name of the YARN queue to which the application is submitted.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.yarn.jars",
    "Default": "(none)",
    "Meaning": "List of libraries containing Spark code to distribute to YARN containers. By default, Spark on YARN will use Spark jars installed locally, but the Spark jars can also be in a world-readable location on HDFS. This allows YARN to cache it on nodes so that it doesn\u0027t need to be distributed each time an application runs. To point to jars on HDFS, for example, set this configuration to hdfs:///some/path. Globs are allowed.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.yarn.archive",
    "Default": "(none)",
    "Meaning": "An archive containing needed Spark jars for distribution to the YARN cache. If set, this configuration replaces spark.yarn.jars and the archive is used in all the application\u0027s containers. The archive should contain jar files in its root directory. Like with the previous option, the archive can also be hosted on HDFS to speed up file distribution.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.yarn.appMasterEnv.[EnvironmentVariableName]",
    "Default": "(none)",
    "Meaning": "Add the environment variable specified by EnvironmentVariableName to the Application Master process launched on YARN. The user can specify multiple of these and to set multiple environment variables. In cluster mode this controls the environment of the Spark driver and in client mode it only controls the environment of the executor launcher.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.yarn.containerLauncherMaxThreads",
    "Default": "25",
    "Meaning": "The maximum number of threads to use in the YARN Application Master for launching executor containers.",
    "Since Version": "1.2.0"
  },
  {
    "Property Name": "spark.yarn.am.extraJavaOptions",
    "Default": "(none)",
    "Meaning": "A string of extra JVM options to pass to the YARN Application Master in client mode. In cluster mode, use spark.driver.extraJavaOptions instead. Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap size settings can be set with spark.yarn.am.memory",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.yarn.am.extraLibraryPath",
    "Default": "(none)",
    "Meaning": "Set a special library path to use when launching the YARN Application Master in client mode.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.yarn.populateHadoopClasspath",
    "Default": "For with-hadoop Spark distribution, this is set to false; for no-hadoop distribution, this is set to true.",
    "Meaning": "Whether to populate Hadoop classpath from yarn.application.classpath and mapreduce.application.classpath Note that if this is set to false, it requires a with-Hadoop Spark distribution that bundles Hadoop runtime or user has to provide a Hadoop installation separately.",
    "Since Version": "2.4.6"
  },
  {
    "Property Name": "spark.yarn.maxAppAttempts",
    "Default": "yarn.resourcemanager.am.max-attempts in YARN",
    "Meaning": "The maximum number of attempts that will be made to submit the application. It should be no larger than the global number of max attempts in the YARN configuration.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.yarn.am.attemptFailuresValidityInterval",
    "Default": "(none)",
    "Meaning": "Defines the validity interval for AM failure tracking. If the AM has been running for at least the defined interval, the AM failure count will be reset. This feature is not enabled if not configured.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.yarn.am.clientModeTreatDisconnectAsFailed",
    "Default": "false",
    "Meaning": "Treat yarn-client unclean disconnects as failures. In yarn-client mode, normally the application will always finish with a final status of SUCCESS because in some cases, it is not possible to know if the Application was terminated intentionally by the user or if there was a real error. This config changes that behavior such that if the Application Master disconnects from the driver uncleanly (ie without the proper shutdown handshake) the application will terminate with a final status of FAILED. This will allow the caller to decide if it was truly a failure. Note that if this config is set and the user just terminate the client application badly it may show a status of FAILED when it wasn\u0027t really FAILED.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.yarn.am.clientModeExitOnError",
    "Default": "false",
    "Meaning": "In yarn-client mode, when this is true, if driver got application report with final status of KILLED or FAILED, driver will stop corresponding SparkContext and exit program with code 1. Note, if this is true and called from another application, it will terminate the parent application as well.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.yarn.am.tokenConfRegex",
    "Default": "(none)",
    "Meaning": "The value of this config is a regex expression used to grep a list of config entries from the job\u0027s configuration file (e.g., hdfs-site.xml) and send to RM, which uses them when renewing delegation tokens. A typical use case of this feature is to support delegation tokens in an environment where a YARN cluster needs to talk to multiple downstream HDFS clusters, where the YARN RM may not have configs (e.g., dfs.nameservices, dfs.ha.namenodes.*, dfs.namenode.rpc-address.*) to connect to these clusters. In this scenario, Spark users can specify the config value to be ^dfs.nameservices$|^dfs.namenode.rpc-address.*$|^dfs.ha.namenodes.*$ to parse these HDFS configs from the job\u0027s local configuration files. This config is very similar to mapreduce.job.send-token-conf. Please check YARN-5910 for more details.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.yarn.submit.waitAppCompletion",
    "Default": "true",
    "Meaning": "In YARN cluster mode, controls whether the client waits to exit until the application completes. If set to true, the client process will stay alive reporting the application\u0027s status. Otherwise, the client process will exit after submission.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.yarn.am.nodeLabelExpression",
    "Default": "(none)",
    "Meaning": "A YARN node label expression that restricts the set of nodes AM will be scheduled on. Only versions of YARN greater than or equal to 2.6 support node label expressions, so when running against earlier versions, this property will be ignored.",
    "Since Version": "1.6.0"
  },
  {
    "Property Name": "spark.yarn.executor.nodeLabelExpression",
    "Default": "(none)",
    "Meaning": "A YARN node label expression that restricts the set of nodes executors will be scheduled on. Only versions of YARN greater than or equal to 2.6 support node label expressions, so when running against earlier versions, this property will be ignored.",
    "Since Version": "1.4.0"
  },
  {
    "Property Name": "spark.yarn.tags",
    "Default": "(none)",
    "Meaning": "Comma-separated list of strings to pass through as YARN application tags appearing in YARN ApplicationReports, which can be used for filtering when querying YARN apps.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.yarn.priority",
    "Default": "(none)",
    "Meaning": "Application priority for YARN to define pending applications ordering policy, those with higher integer value have a better opportunity to be activated. Currently, YARN only supports application priority when using FIFO ordering policy.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.config.gatewayPath",
    "Default": "(none)",
    "Meaning": "A path that is valid on the gateway host (the host where a Spark application is started) but may differ for paths for the same resource in other nodes in the cluster. Coupled with spark.yarn.config.replacementPath, this is used to support clusters with heterogeneous configurations, so that Spark can correctly launch remote processes. The replacement path normally will contain a reference to some environment variable exported by YARN (and, thus, visible to Spark containers). For example, if the gateway node has Hadoop libraries installed on /disk1/hadoop, and the location of the Hadoop install is exported by YARN as the HADOOP_HOME environment variable, setting this value to /disk1/hadoop and the replacement path to $HADOOP_HOME will make sure that paths used to launch remote processes properly reference the local YARN configuration.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.yarn.config.replacementPath",
    "Default": "(none)",
    "Meaning": "See spark.yarn.config.gatewayPath.",
    "Since Version": "1.5.0"
  },
  {
    "Property Name": "spark.yarn.rolledLog.includePattern",
    "Default": "(none)",
    "Meaning": "Java Regex to filter the log files which match the defined include pattern and those log files will be aggregated in a rolling fashion. This will be used with YARN\u0027s rolling log aggregation, to enable this feature in YARN side yarn.nodemanager.log-aggregation.roll-monitoring-interval-seconds should be configured in yarn-site.xml. The Spark log4j appender needs be changed to use FileAppender or another appender that can handle the files being removed while it is running. Based on the file name configured in the log4j configuration (like spark.log), the user should set the regex (spark*) to include all the log files that need to be aggregated.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.yarn.rolledLog.excludePattern",
    "Default": "(none)",
    "Meaning": "Java Regex to filter the log files which match the defined exclude pattern and those log files will not be aggregated in a rolling fashion. If the log file name matches both the include and the exclude pattern, this file will be excluded eventually.",
    "Since Version": "2.0.0"
  },
  {
    "Property Name": "spark.yarn.executor.launch.excludeOnFailure.enabled",
    "Default": "false",
    "Meaning": "Flag to enable exclusion of nodes having YARN resource allocation problems. The error limit for excluding can be configured by spark.excludeOnFailure.application.maxFailedExecutorsPerNode.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.yarn.exclude.nodes",
    "Default": "(none)",
    "Meaning": "Comma-separated list of YARN node names which are excluded from resource allocation.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.metrics.namespace",
    "Default": "(none)",
    "Meaning": "The root namespace for AM metrics reporting. If it is not set then the YARN application ID is used.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.yarn.report.interval",
    "Default": "1s",
    "Meaning": "Interval between reports of the current Spark job status in cluster mode.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.yarn.report.loggingFrequency",
    "Default": "30",
    "Meaning": "Maximum number of application reports processed until the next application status is logged. If there is a change of state, the application status will be logged regardless of the number of application reports processed.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.yarn.clientLaunchMonitorInterval",
    "Default": "1s",
    "Meaning": "Interval between requests for status the client mode AM when starting the app.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.yarn.includeDriverLogsLink",
    "Default": "false",
    "Meaning": "In cluster mode, whether the client application report includes links to the driver container\u0027s logs. This requires polling the ResourceManager\u0027s REST API, so it places some additional load on the RM.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.yarn.unmanagedAM.enabled",
    "Default": "false",
    "Meaning": "In client mode, whether to launch the Application Master service as part of the client using unmanaged am.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.shuffle.server.recovery.disabled",
    "Default": "false",
    "Meaning": "Set to true for applications that have higher security requirements and prefer that their secret is not saved in the db. The shuffle data of such applications wll not be recovered after the External Shuffle Service restarts.",
    "Since Version": "3.5.0"
  },
  {
    "Property Name": "spark.kerberos.keytab",
    "Default": "(none)",
    "Meaning": "The full path to the file that contains the keytab for the principal specified above. This keytab will be copied to the node running the YARN Application Master via the YARN Distributed Cache, and will be used for renewing the login tickets and the delegation tokens periodically. Equivalent to the --keytab command line argument. (Works also with the \"local\" master.)",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kerberos.principal",
    "Default": "(none)",
    "Meaning": "Principal to be used to login to KDC, while running on secure clusters. Equivalent to the --principal command line argument. (Works also with the \"local\" master.)",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.yarn.kerberos.relogin.period",
    "Default": "1m",
    "Meaning": "How often to check whether the kerberos TGT should be renewed. This should be set to a value that is shorter than the TGT renewal period (or the TGT lifetime if TGT renewal is not enabled). The default value should be enough for most deployments.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.yarn.kerberos.renewal.excludeHadoopFileSystems",
    "Default": "(none)",
    "Meaning": "A comma-separated list of Hadoop filesystems for whose hosts will be excluded from delegation token renewal at resource scheduler. For example, spark.yarn.kerberos.renewal.excludeHadoopFileSystems\u003dhdfs://nn1.com:8032, hdfs://nn2.com:8032. This is known to work under YARN for now, so YARN Resource Manager won\u0027t renew tokens for the application. Note that as resource scheduler does not renew token, so any application running longer than the original token expiration that tries to use that token will likely fail.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.yarn.shuffle.stopOnFailure",
    "Default": "false",
    "Meaning": "Whether to stop the NodeManager when there\u0027s a failure in the Spark Shuffle Service\u0027s initialization. This prevents application failures caused by running containers on NodeManagers where the Spark Shuffle Service is not running.",
    "Since Version": "2.1.0"
  },
  {
    "Property Name": "spark.yarn.shuffle.service.metrics.namespace",
    "Default": "sparkShuffleService",
    "Meaning": "The namespace to use when emitting shuffle service metrics into Hadoop metrics2 system of the NodeManager.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.yarn.shuffle.service.logs.namespace",
    "Default": "(not set)",
    "Meaning": "A namespace which will be appended to the class name when forming the logger name to use for emitting logs from the YARN shuffle service, like org.apache.spark.network.yarn.YarnShuffleService.logsNamespaceValue. Since some logging frameworks may expect the logger name to look like a class name, it\u0027s generally recommended to provide a value which would be a valid Java package or class name and not include spaces.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.shuffle.service.db.backend",
    "Default": "LEVELDB",
    "Meaning": "When work-preserving restart is enabled in YARN, this is used to specify the disk-base store used in shuffle service state store, supports `LEVELDB` and `ROCKSDB` with `LEVELDB` as default value. The original data store in `LevelDB/RocksDB` will not be automatically converted to another kind of storage now. The original data store will be retained and the new type data store will be created when switching storage types.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.kubernetes.context",
    "Default": "(none)",
    "Meaning": "The context from the user Kubernetes configuration file used for the initial auto-configuration of the Kubernetes client library. When not specified then the users current context is used. NB: Many of the auto-configured settings can be overridden by the use of other Spark configuration properties e.g. spark.kubernetes.namespace.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.master",
    "Default": "https://kubernetes.default.svc",
    "Meaning": "The internal Kubernetes master (API server) address to be used for driver to request executors or \u0027local[*]\u0027 for driver-pod-only mode.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.namespace",
    "Default": "default",
    "Meaning": "The namespace that will be used for running the driver and executor pods.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.container.image",
    "Default": "(none)",
    "Meaning": "Container image to use for the Spark application. This is usually of the form example.com/repo/spark:v1.0.0. This configuration is required and must be provided by the user, unless explicit images are provided for each different container type.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.container.image",
    "Default": "(value of spark.kubernetes.container.image)",
    "Meaning": "Custom container image to use for the driver.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.container.image",
    "Default": "(value of spark.kubernetes.container.image)",
    "Meaning": "Custom container image to use for executors.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.container.image.pullPolicy",
    "Default": "IfNotPresent",
    "Meaning": "Container image pull policy used when pulling images within Kubernetes. Valid values are Always, Never, and IfNotPresent.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.container.image.pullSecrets",
    "Default": "",
    "Meaning": "Comma separated list of Kubernetes secrets used to pull images from private image registries.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.allocation.batch.size",
    "Default": "5",
    "Meaning": "Number of pods to launch at once in each round of executor pod allocation.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.allocation.batch.delay",
    "Default": "1s",
    "Meaning": "Time to wait between each round of executor pod allocation. Specifying values less than 1 second may lead to excessive CPU usage on the spark driver.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.submission.caCertFile",
    "Default": "(none)",
    "Meaning": "Path to the CA cert file for connecting to the Kubernetes API server over TLS when starting the driver. This file must be located on the submitting machine\u0027s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.caCertFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.submission.clientKeyFile",
    "Default": "(none)",
    "Meaning": "Path to the client key file for authenticating against the Kubernetes API server when starting the driver. This file must be located on the submitting machine\u0027s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.clientKeyFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.submission.clientCertFile",
    "Default": "(none)",
    "Meaning": "Path to the client cert file for authenticating against the Kubernetes API server when starting the driver. This file must be located on the submitting machine\u0027s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.clientCertFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.submission.oauthToken",
    "Default": "(none)",
    "Meaning": "OAuth token to use when authenticating against the Kubernetes API server when starting the driver. Note that unlike the other authentication options, this is expected to be the exact string value of the token to use for the authentication. In client mode, use spark.kubernetes.authenticate.oauthToken instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.submission.oauthTokenFile",
    "Default": "(none)",
    "Meaning": "Path to the OAuth token file containing the token to use when authenticating against the Kubernetes API server when starting the driver. This file must be located on the submitting machine\u0027s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.oauthTokenFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.caCertFile",
    "Default": "(none)",
    "Meaning": "Path to the CA cert file for connecting to the Kubernetes API server over TLS from the driver pod when requesting executors. This file must be located on the submitting machine\u0027s disk, and will be uploaded to the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.caCertFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.clientKeyFile",
    "Default": "(none)",
    "Meaning": "Path to the client key file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This file must be located on the submitting machine\u0027s disk, and will be uploaded to the driver pod as a Kubernetes secret. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.clientKeyFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.clientCertFile",
    "Default": "(none)",
    "Meaning": "Path to the client cert file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This file must be located on the submitting machine\u0027s disk, and will be uploaded to the driver pod as a Kubernetes secret. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.clientCertFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.oauthToken",
    "Default": "(none)",
    "Meaning": "OAuth token to use when authenticating against the Kubernetes API server from the driver pod when requesting executors. Note that unlike the other authentication options, this must be the exact string value of the token to use for the authentication. This token value is uploaded to the driver pod as a Kubernetes secret. In client mode, use spark.kubernetes.authenticate.oauthToken instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.oauthTokenFile",
    "Default": "(none)",
    "Meaning": "Path to the OAuth token file containing the token to use when authenticating against the Kubernetes API server from the driver pod when requesting executors. Note that unlike the other authentication options, this file must contain the exact string value of the token to use for the authentication. This token value is uploaded to the driver pod as a secret. In client mode, use spark.kubernetes.authenticate.oauthTokenFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.mounted.caCertFile",
    "Default": "(none)",
    "Meaning": "Path to the CA cert file for connecting to the Kubernetes API server over TLS from the driver pod when requesting executors. This path must be accessible from the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.caCertFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.mounted.clientKeyFile",
    "Default": "(none)",
    "Meaning": "Path to the client key file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This path must be accessible from the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.clientKeyFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.mounted.clientCertFile",
    "Default": "(none)",
    "Meaning": "Path to the client cert file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This path must be accessible from the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). In client mode, use spark.kubernetes.authenticate.clientCertFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.mounted.oauthTokenFile",
    "Default": "(none)",
    "Meaning": "Path to the file containing the OAuth token to use when authenticating against the Kubernetes API server from the driver pod when requesting executors. This path must be accessible from the driver pod. Note that unlike the other authentication options, this file must contain the exact string value of the token to use for the authentication. In client mode, use spark.kubernetes.authenticate.oauthTokenFile instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.driver.serviceAccountName",
    "Default": "default",
    "Meaning": "Service account that is used when running the driver pod. The driver pod uses this service account when requesting executor pods from the API server. Note that this cannot be specified alongside a CA cert file, client key file, client cert file, and/or OAuth token. In client mode, use spark.kubernetes.authenticate.serviceAccountName instead.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.executor.serviceAccountName",
    "Default": "(value of spark.kubernetes.authenticate.driver.serviceAccountName)",
    "Meaning": "Service account that is used when running the executor pod. If this parameter is not setup, the fallback logic will use the driver\u0027s service account.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.caCertFile",
    "Default": "(none)",
    "Meaning": "In client mode, path to the CA cert file for connecting to the Kubernetes API server over TLS when requesting executors. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.clientKeyFile",
    "Default": "(none)",
    "Meaning": "In client mode, path to the client key file for authenticating against the Kubernetes API server when requesting executors. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.clientCertFile",
    "Default": "(none)",
    "Meaning": "In client mode, path to the client cert file for authenticating against the Kubernetes API server when requesting executors. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.oauthToken",
    "Default": "(none)",
    "Meaning": "In client mode, the OAuth token to use when authenticating against the Kubernetes API server when requesting executors. Note that unlike the other authentication options, this must be the exact string value of the token to use for the authentication.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.authenticate.oauthTokenFile",
    "Default": "(none)",
    "Meaning": "In client mode, path to the file containing the OAuth token to use when authenticating against the Kubernetes API server when requesting executors.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.label.[LabelName]",
    "Default": "(none)",
    "Meaning": "Add the label specified by LabelName to the driver pod. For example, spark.kubernetes.driver.label.something\u003dtrue. Note that Spark also adds its own labels to the driver pod for bookkeeping purposes.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.annotation.[AnnotationName]",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes annotation specified by AnnotationName to the driver pod. For example, spark.kubernetes.driver.annotation.something\u003dtrue.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.service.label.[LabelName]",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes label specified by LabelName to the driver service. For example, spark.kubernetes.driver.service.label.something\u003dtrue. Note that Spark also adds its own labels to the driver service for bookkeeping purposes.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.service.annotation.[AnnotationName]",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes annotation specified by AnnotationName to the driver service. For example, spark.kubernetes.driver.service.annotation.something\u003dtrue.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.label.[LabelName]",
    "Default": "(none)",
    "Meaning": "Add the label specified by LabelName to the executor pods. For example, spark.kubernetes.executor.label.something\u003dtrue. Note that Spark also adds its own labels to the executor pod for bookkeeping purposes.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.annotation.[AnnotationName]",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes annotation specified by AnnotationName to the executor pods. For example, spark.kubernetes.executor.annotation.something\u003dtrue.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.pod.name",
    "Default": "(none)",
    "Meaning": "Name of the driver pod. In cluster mode, if this is not set, the driver pod name is set to \"spark.app.name\" suffixed by the current timestamp to avoid name conflicts. In client mode, if your application is running inside a pod, it is highly recommended to set this to the name of the pod your driver is running in. Setting this value in client mode allows the driver to become the owner of its executor pods, which in turn allows the executor pods to be garbage collected by the cluster.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.podNamePrefix",
    "Default": "(none)",
    "Meaning": "Prefix to use in front of the executor pod names. It must conform the rules defined by the Kubernetes DNS Label Names. The prefix will be used to generate executor pod names in the form of $podNamePrefix-exec-$id, where the `id` is a positive int value, so the length of the `podNamePrefix` needs to be less than or equal to 47(\u003d 63 - 10 - 6).",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.submission.waitAppCompletion",
    "Default": "true",
    "Meaning": "In cluster mode, whether to wait for the application to finish before exiting the launcher process. When changed to false, the launcher has a \"fire-and-forget\" behavior when launching the Spark job.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.report.interval",
    "Default": "1s",
    "Meaning": "Interval between reports of the current Spark job status in cluster mode.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.apiPollingInterval",
    "Default": "30s",
    "Meaning": "Interval between polls against the Kubernetes API server to inspect the state of executors.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.request.cores",
    "Default": "(none)",
    "Meaning": "Specify the cpu request for the driver pod. Values conform to the Kubernetes convention. Example values include 0.1, 500m, 1.5, 5, etc., with the definition of cpu units documented in CPU units. This takes precedence over spark.driver.cores for specifying the driver pod cpu request if set.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.limit.cores",
    "Default": "(none)",
    "Meaning": "Specify a hard cpu limit for the driver pod.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.request.cores",
    "Default": "(none)",
    "Meaning": "Specify the cpu request for each executor pod. Values conform to the Kubernetes convention. Example values include 0.1, 500m, 1.5, 5, etc., with the definition of cpu units documented in CPU units. This is distinct from spark.executor.cores: it is only used and takes precedence over spark.executor.cores for specifying the executor pod cpu request if set. Task parallelism, e.g., number of tasks an executor can run concurrently is not affected by this.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.limit.cores",
    "Default": "(none)",
    "Meaning": "Specify a hard cpu limit for each executor pod launched for the Spark Application.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.node.selector.[labelKey]",
    "Default": "(none)",
    "Meaning": "Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration\u0027s value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.node.selector.[labelKey]",
    "Default": "(none)",
    "Meaning": "Adds to the driver node selector of the driver pod, with key labelKey and the value as the configuration\u0027s value. For example, setting spark.kubernetes.driver.node.selector.identifier to myIdentifier will result in the driver pod having a node selector with key identifier and value myIdentifier. Multiple driver node selector keys can be added by setting multiple configurations with this prefix.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.node.selector.[labelKey]",
    "Default": "(none)",
    "Meaning": "Adds to the executor node selector of the executor pods, with key labelKey and the value as the configuration\u0027s value. For example, setting spark.kubernetes.executor.node.selector.identifier to myIdentifier will result in the executors having a node selector with key identifier and value myIdentifier. Multiple executor node selector keys can be added by setting multiple configurations with this prefix.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driverEnv.[EnvironmentVariableName]",
    "Default": "(none)",
    "Meaning": "Add the environment variable specified by EnvironmentVariableName to the Driver process. The user can specify multiple of these to set multiple environment variables.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.secrets.[SecretName]",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes Secret named SecretName to the driver pod on the path specified in the value. For example, spark.kubernetes.driver.secrets.spark-secret\u003d/etc/secrets.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.secrets.[SecretName]",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes Secret named SecretName to the executor pod on the path specified in the value. For example, spark.kubernetes.executor.secrets.spark-secret\u003d/etc/secrets.",
    "Since Version": "2.3.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.secretKeyRef.[EnvName]",
    "Default": "(none)",
    "Meaning": "Add as an environment variable to the driver container with name EnvName (case sensitive), the value referenced by key key in the data of the referenced Kubernetes Secret. For example, spark.kubernetes.driver.secretKeyRef.ENV_VAR\u003dspark-secret:key.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.secretKeyRef.[EnvName]",
    "Default": "(none)",
    "Meaning": "Add as an environment variable to the executor container with name EnvName (case sensitive), the value referenced by key key in the data of the referenced Kubernetes Secret. For example, spark.kubernetes.executor.secrets.ENV_VAR\u003dspark-secret:key.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.volumes.[VolumeType].[VolumeName].mount.path",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes Volume named VolumeName of the VolumeType type to the driver pod on the path specified in the value. For example, spark.kubernetes.driver.volumes.persistentVolumeClaim.checkpointpvc.mount.path\u003d/checkpoint.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.volumes.[VolumeType].[VolumeName].mount.subPath",
    "Default": "(none)",
    "Meaning": "Specifies a subpath to be mounted from the volume into the driver pod. spark.kubernetes.driver.volumes.persistentVolumeClaim.checkpointpvc.mount.subPath\u003dcheckpoint.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.volumes.[VolumeType].[VolumeName].mount.readOnly",
    "Default": "(none)",
    "Meaning": "Specify if the mounted volume is read only or not. For example, spark.kubernetes.driver.volumes.persistentVolumeClaim.checkpointpvc.mount.readOnly\u003dfalse.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.volumes.[VolumeType].[VolumeName].options.[OptionName]",
    "Default": "(none)",
    "Meaning": "Configure Kubernetes Volume options passed to the Kubernetes with OptionName as key having specified value, must conform with Kubernetes option format. For example, spark.kubernetes.driver.volumes.persistentVolumeClaim.checkpointpvc.options.claimName\u003dspark-pvc-claim.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.volumes.[VolumeType].[VolumeName].mount.path",
    "Default": "(none)",
    "Meaning": "Add the Kubernetes Volume named VolumeName of the VolumeType type to the executor pod on the path specified in the value. For example, spark.kubernetes.executor.volumes.persistentVolumeClaim.checkpointpvc.mount.path\u003d/checkpoint.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.volumes.[VolumeType].[VolumeName].mount.subPath",
    "Default": "(none)",
    "Meaning": "Specifies a subpath to be mounted from the volume into the executor pod. spark.kubernetes.executor.volumes.persistentVolumeClaim.checkpointpvc.mount.subPath\u003dcheckpoint.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.volumes.[VolumeType].[VolumeName].mount.readOnly",
    "Default": "false",
    "Meaning": "Specify if the mounted volume is read only or not. For example, spark.kubernetes.executor.volumes.persistentVolumeClaim.checkpointpvc.mount.readOnly\u003dfalse.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.volumes.[VolumeType].[VolumeName].options.[OptionName]",
    "Default": "(none)",
    "Meaning": "Configure Kubernetes Volume options passed to the Kubernetes with OptionName as key having specified value. For example, spark.kubernetes.executor.volumes.persistentVolumeClaim.checkpointpvc.options.claimName\u003dspark-pvc-claim.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.local.dirs.tmpfs",
    "Default": "false",
    "Meaning": "Configure the emptyDir volumes used to back SPARK_LOCAL_DIRS within the Spark driver and executor pods to use tmpfs backing i.e. RAM. See Local Storage earlier on this page for more discussion of this.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.memoryOverheadFactor",
    "Default": "0.1",
    "Meaning": "This sets the Memory Overhead Factor that will allocate memory to non-JVM memory, which includes off-heap memory allocations, non-JVM tasks, various systems processes, and tmpfs-based local directories when spark.kubernetes.local.dirs.tmpfs is true. For JVM-based jobs this value will default to 0.10 and 0.40 for non-JVM jobs. This is done as non-JVM tasks need more non-JVM heap space and such tasks commonly fail with \"Memory Overhead Exceeded\" errors. This preempts this error with a higher default. This will be overridden by the value set by spark.driver.memoryOverheadFactor and spark.executor.memoryOverheadFactor explicitly.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.pyspark.pythonVersion",
    "Default": "\"3\"",
    "Meaning": "This sets the major Python version of the docker image used to run the driver and executor containers. It can be only \"3\". This configuration was deprecated from Spark 3.1.0, and is effectively no-op. Users should set \u0027spark.pyspark.python\u0027 and \u0027spark.pyspark.driver.python\u0027 configurations or \u0027PYSPARK_PYTHON\u0027 and \u0027PYSPARK_DRIVER_PYTHON\u0027 environment variables.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.kerberos.krb5.path",
    "Default": "(none)",
    "Meaning": "Specify the local location of the krb5.conf file to be mounted on the driver and executors for Kerberos interaction. It is important to note that the KDC defined needs to be visible from inside the containers.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.kerberos.krb5.configMapName",
    "Default": "(none)",
    "Meaning": "Specify the name of the ConfigMap, containing the krb5.conf file, to be mounted on the driver and executors for Kerberos interaction. The KDC defined needs to be visible from inside the containers. The ConfigMap must also be in the same namespace of the driver and executor pods.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.hadoop.configMapName",
    "Default": "(none)",
    "Meaning": "Specify the name of the ConfigMap, containing the HADOOP_CONF_DIR files, to be mounted on the driver and executors for custom Hadoop configuration.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.kerberos.tokenSecret.name",
    "Default": "(none)",
    "Meaning": "Specify the name of the secret where your existing delegation tokens are stored. This removes the need for the job user to provide any kerberos credentials for launching a job.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.kerberos.tokenSecret.itemKey",
    "Default": "(none)",
    "Meaning": "Specify the item key of the data where your existing delegation tokens are stored. This removes the need for the job user to provide any kerberos credentials for launching a job.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.podTemplateFile",
    "Default": "(none)",
    "Meaning": "Specify the local file that contains the driver pod template. For example spark.kubernetes.driver.podTemplateFile\u003d/path/to/driver-pod-template.yaml",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.podTemplateContainerName",
    "Default": "(none)",
    "Meaning": "Specify the container name to be used as a basis for the driver in the given pod template. For example spark.kubernetes.driver.podTemplateContainerName\u003dspark-driver",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.podTemplateFile",
    "Default": "(none)",
    "Meaning": "Specify the local file that contains the executor pod template. For example spark.kubernetes.executor.podTemplateFile\u003d/path/to/executor-pod-template.yaml",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.podTemplateContainerName",
    "Default": "(none)",
    "Meaning": "Specify the container name to be used as a basis for the executor in the given pod template. For example spark.kubernetes.executor.podTemplateContainerName\u003dspark-executor",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.deleteOnTermination",
    "Default": "true",
    "Meaning": "Specify whether executor pods should be deleted in case of failure or normal termination.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.checkAllContainers",
    "Default": "false",
    "Meaning": "Specify whether executor pods should be check all containers (including sidecars) or only the executor container when determining the pod status.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.kubernetes.submission.connectionTimeout",
    "Default": "10000",
    "Meaning": "Connection timeout in milliseconds for the kubernetes client to use for starting the driver.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.submission.requestTimeout",
    "Default": "10000",
    "Meaning": "Request timeout in milliseconds for the kubernetes client to use for starting the driver.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.trust.certificates",
    "Default": "false",
    "Meaning": "If set to true then client can submit to kubernetes cluster only with token.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.connectionTimeout",
    "Default": "10000",
    "Meaning": "Connection timeout in milliseconds for the kubernetes client in driver to use when requesting executors.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.requestTimeout",
    "Default": "10000",
    "Meaning": "Request timeout in milliseconds for the kubernetes client in driver to use when requesting executors.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.appKillPodDeletionGracePeriod",
    "Default": "(none)",
    "Meaning": "Specify the grace period in seconds when deleting a Spark application using spark-submit.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.dynamicAllocation.deleteGracePeriod",
    "Default": "5s",
    "Meaning": "How long to wait for executors to shut down gracefully before a forceful kill.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.file.upload.path",
    "Default": "(none)",
    "Meaning": "Path to store files at the spark submit side in cluster mode. For example: spark.kubernetes.file.upload.path\u003ds3a://\u003cs3-bucket\u003e/path File should specified as file://path/to/file or absolute path.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.decommissionLabel",
    "Default": "(none)",
    "Meaning": "Label to be applied to pods which are exiting or being decommissioned. Intended for use with pod disruption budgets, deletion costs, and similar.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.decommissionLabelValue",
    "Default": "(none)",
    "Meaning": "Value to be applied with the label when spark.kubernetes.executor.decommissionLabel is enabled.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.scheduler.name",
    "Default": "(none)",
    "Meaning": "Specify the scheduler name for each executor pod.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.scheduler.name",
    "Default": "(none)",
    "Meaning": "Specify the scheduler name for driver pod.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.scheduler.name",
    "Default": "(none)",
    "Meaning": "Specify the scheduler name for driver and executor pods. If `spark.kubernetes.driver.scheduler.name` or `spark.kubernetes.executor.scheduler.name` is set, will override this.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.configMap.maxSize",
    "Default": "1572864",
    "Meaning": "Max size limit for a config map. This is configurable as per limit on k8s server end.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.missingPodDetectDelta",
    "Default": "30s",
    "Meaning": "When a registered executor\u0027s POD is missing from the Kubernetes API server\u0027s polled list of PODs then this delta time is taken as the accepted time difference between the registration time and the time of the polling. After this time the POD is considered missing from the cluster and the executor will be removed.",
    "Since Version": "3.1.1"
  },
  {
    "Property Name": "spark.kubernetes.decommission.script",
    "Default": "/opt/decom.sh",
    "Meaning": "The location of the script to use for graceful decommissioning.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.service.deleteOnTermination",
    "Default": "true",
    "Meaning": "If true, driver service will be deleted on Spark application termination. If false, it will be cleaned up when the driver pod is deletion.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.service.ipFamilyPolicy",
    "Default": "SingleStack",
    "Meaning": "K8s IP Family Policy for Driver Service. Valid values are SingleStack, PreferDualStack, and RequireDualStack.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.service.ipFamilies",
    "Default": "IPv4",
    "Meaning": "A list of IP families for K8s Driver Service. Valid values are IPv4 and IPv6.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.ownPersistentVolumeClaim",
    "Default": "true",
    "Meaning": "If true, driver pod becomes the owner of on-demand persistent volume claims instead of the executor pods",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.reusePersistentVolumeClaim",
    "Default": "true",
    "Meaning": "If true, driver pod tries to reuse driver-owned on-demand persistent volume claims of the deleted executor pods if exists. This can be useful to reduce executor pod creation delay by skipping persistent volume creations. Note that a pod in `Terminating` pod status is not a deleted pod by definition and its resources including persistent volume claims are not reusable yet. Spark will create new persistent volume claims when there exists no reusable one. In other words, the total number of persistent volume claims can be larger than the number of running executors sometimes. This config requires spark.kubernetes.driver.ownPersistentVolumeClaim\u003dtrue.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.waitToReusePersistentVolumeClaim",
    "Default": "false",
    "Meaning": "If true, driver pod counts the number of created on-demand persistent volume claims and wait if the number is greater than or equal to the total number of volumes which the Spark job is able to have. This config requires both spark.kubernetes.driver.ownPersistentVolumeClaim\u003dtrue and spark.kubernetes.driver.reusePersistentVolumeClaim\u003dtrue.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.disableConfigMap",
    "Default": "false",
    "Meaning": "If true, disable ConfigMap creation for executors.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.driver.pod.featureSteps",
    "Default": "(none)",
    "Meaning": "Class names of an extra driver pod feature step implementing `KubernetesFeatureConfigStep`. This is a developer API. Comma separated. Runs after all of Spark internal feature steps. Since 3.3.0, your driver feature step can implement `KubernetesDriverCustomFeatureConfigStep` where the driver config is also available.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.pod.featureSteps",
    "Default": "(none)",
    "Meaning": "Class names of an extra executor pod feature step implementing `KubernetesFeatureConfigStep`. This is a developer API. Comma separated. Runs after all of Spark internal feature steps. Since 3.3.0, your executor feature step can implement `KubernetesExecutorCustomFeatureConfigStep` where the executor config is also available.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.allocation.maxPendingPods",
    "Default": "Int.MaxValue",
    "Meaning": "Maximum number of pending PODs allowed during executor allocation for this application. Those newly requested executors which are unknown by Kubernetes yet are also counted into this limit as they will change into pending PODs by time. This limit is independent from the resource profiles as it limits the sum of all allocation for all the used resource profiles.",
    "Since Version": "3.2.0"
  },
  {
    "Property Name": "spark.kubernetes.allocation.pods.allocator",
    "Default": "direct",
    "Meaning": "Allocator to use for pods. Possible values are direct (the default) and statefulset, or a full class name of a class implementing `AbstractPodsAllocator`. Future version may add Job or replicaset. This is a developer API and may change or be removed at anytime.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.allocation.executor.timeout",
    "Default": "600s",
    "Meaning": "Time to wait before a newly created executor POD request, which does not reached the POD pending state yet, considered timedout and will be deleted.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.kubernetes.allocation.driver.readinessTimeout",
    "Default": "1s",
    "Meaning": "Time to wait for driver pod to get ready before creating executor pods. This wait only happens on application start. If timeout happens, executor pods will still be created.",
    "Since Version": "3.1.3"
  },
  {
    "Property Name": "spark.kubernetes.executor.enablePollingWithResourceVersion",
    "Default": "false",
    "Meaning": "If true, `resourceVersion` is set with `0` during invoking pod listing APIs in order to allow API Server-side caching. This should be used carefully.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.eventProcessingInterval",
    "Default": "1s",
    "Meaning": "Interval between successive inspection of executor events sent from the Kubernetes API.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.rollInterval",
    "Default": "0s",
    "Meaning": "Interval between executor roll operations. It\u0027s disabled by default with `0s`.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.minTasksPerExecutorBeforeRolling",
    "Default": "0",
    "Meaning": "The minimum number of tasks per executor before rolling. Spark will not roll executors whose total number of tasks is smaller than this configuration. The default value is zero.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.kubernetes.executor.rollPolicy",
    "Default": "OUTLIER",
    "Meaning": "Executor roll policy: Valid values are ID, ADD_TIME, TOTAL_GC_TIME, TOTAL_DURATION, FAILED_TASKS, and OUTLIER (default). When executor roll happens, Spark uses this policy to choose an executor and decommission it. The built-in policies are based on executor summary and newly started executors are protected by spark.kubernetes.executor.minTasksPerExecutorBeforeRolling. ID policy chooses an executor with the smallest executor ID. ADD_TIME policy chooses an executor with the smallest add-time. TOTAL_GC_TIME policy chooses an executor with the biggest total task GC time. TOTAL_DURATION policy chooses an executor with the biggest total task time. AVERAGE_DURATION policy chooses an executor with the biggest average task time. FAILED_TASKS policy chooses an executor with the most number of failed tasks. OUTLIER policy chooses an executor with outstanding statistics which is bigger than at least two standard deviation from the mean in average task time, total task time, total task GC time, and the number of failed tasks if exists. If there is no outlier, it works like TOTAL_DURATION policy.",
    "Since Version": "3.3.0"
  },
  {
    "Property Name": "spark.master.ui.port",
    "Default": "8080",
    "Meaning": "Specifies the port number of the Master Web UI endpoint.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.master.ui.decommission.allow.mode",
    "Default": "LOCAL",
    "Meaning": "Specifies the behavior of the Master Web UI\u0027s /workers/kill endpoint. Possible choices are: LOCAL means allow this endpoint from IP\u0027s that are local to the machine running the Master, DENY means to completely disable this endpoint, ALLOW means to allow calling this endpoint from any IP.",
    "Since Version": "3.1.0"
  },
  {
    "Property Name": "spark.master.rest.enabled",
    "Default": "false",
    "Meaning": "Whether to use the Master REST API endpoint or not.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.master.rest.port",
    "Default": "6066",
    "Meaning": "Specifies the port number of the Master REST API endpoint.",
    "Since Version": "1.3.0"
  },
  {
    "Property Name": "spark.deploy.retainedApplications",
    "Default": "200",
    "Meaning": "The maximum number of completed applications to display. Older applications will be dropped from the UI to maintain this limit.",
    "Since Version": "0.8.0"
  },
  {
    "Property Name": "spark.deploy.retainedDrivers",
    "Default": "200",
    "Meaning": "The maximum number of completed drivers to display. Older drivers will be dropped from the UI to maintain this limit.",
    "Since Version": "1.1.0"
  },
  {
    "Property Name": "spark.deploy.spreadOut",
    "Default": "true",
    "Meaning": "Whether the standalone cluster manager should spread applications out across nodes or try to consolidate them onto as few nodes as possible. Spreading out is usually better for data locality in HDFS, but consolidating is more efficient for compute-intensive workloads.",
    "Since Version": "0.6.1"
  },
  {
    "Property Name": "spark.deploy.defaultCores",
    "Default": "(infinite)",
    "Meaning": "Default number of cores to give to applications in Spark\u0027s standalone mode if they don\u0027t set spark.cores.max. If not set, applications always get all available cores unless they configure spark.cores.max themselves. Set this lower on a shared cluster to prevent users from grabbing the whole cluster by default.",
    "Since Version": "0.9.0"
  },
  {
    "Property Name": "spark.deploy.maxExecutorRetries",
    "Default": "10",
    "Meaning": "Limit on the maximum number of back-to-back executor failures that can occur before the standalone cluster manager removes a faulty application. An application will never be removed if it has any running executors. If an application experiences more than spark.deploy.maxExecutorRetries failures in a row, no executors successfully start running in between those failures, and the application has no running executors then the standalone cluster manager will remove the application and mark it as failed. To disable this automatic removal, set spark.deploy.maxExecutorRetries to -1.",
    "Since Version": "1.6.3"
  },
  {
    "Property Name": "spark.worker.timeout",
    "Default": "60",
    "Meaning": "Number of seconds after which the standalone deploy master considers a worker lost if it receives no heartbeats.",
    "Since Version": "0.6.2"
  },
  {
    "Property Name": "spark.worker.resource.{name}.amount",
    "Default": "(none)",
    "Meaning": "Amount of a particular resource to use on the worker.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.worker.resource.{name}.discoveryScript",
    "Default": "(none)",
    "Meaning": "Path to resource discovery script, which is used to find a particular resource while worker starting up. And the output of the script should be formatted like the ResourceInformation class.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.worker.resourcesFile",
    "Default": "(none)",
    "Meaning": "Path to resources file which is used to find various resources while worker starting up. The content of resources file should be formatted like [{\"id\":{\"componentName\": \"spark.worker\", \"resourceName\":\"gpu\"}, \"addresses\":[\"0\",\"1\",\"2\"]}]. If a particular resource is not found in the resources file, the discovery script would be used to find that resource. If the discovery script also does not find the resources, the worker will fail to start up.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.worker.cleanup.enabled",
    "Default": "false",
    "Meaning": "Enable periodic cleanup of worker / application directories. Note that this only affects standalone mode, as YARN works differently. Only the directories of stopped applications are cleaned up. This should be enabled if spark.shuffle.service.db.enabled is \"true\"",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.worker.cleanup.interval",
    "Default": "1800 (30 minutes)",
    "Meaning": "Controls the interval, in seconds, at which the worker cleans up old application work dirs on the local machine.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.worker.cleanup.appDataTtl",
    "Default": "604800 (7 days, 7 * 24 * 3600)",
    "Meaning": "The number of seconds to retain application work directories on each worker. This is a Time To Live and should depend on the amount of available disk space you have. Application logs and jars are downloaded to each application work dir. Over time, the work dirs can quickly fill up disk space, especially if you run jobs very frequently.",
    "Since Version": "1.0.0"
  },
  {
    "Property Name": "spark.shuffle.service.db.enabled",
    "Default": "true",
    "Meaning": "Store External Shuffle service state on local disk so that when the external shuffle service is restarted, it will automatically reload info on current executors. This only affects standalone mode (yarn always has this behavior enabled). You should also enable spark.worker.cleanup.enabled, to ensure that the state eventually gets cleaned up. This config may be removed in the future.",
    "Since Version": "3.0.0"
  },
  {
    "Property Name": "spark.shuffle.service.db.backend",
    "Default": "LEVELDB",
    "Meaning": "When spark.shuffle.service.db.enabled is true, user can use this to specify the kind of disk-based store used in shuffle service state store. This supports `LEVELDB` and `ROCKSDB` now and `LEVELDB` as default value. The original data store in `LevelDB/RocksDB` will not be automatically convert to another kind of storage now.",
    "Since Version": "3.4.0"
  },
  {
    "Property Name": "spark.storage.cleanupFilesAfterExecutorExit",
    "Default": "true",
    "Meaning": "Enable cleanup non-shuffle files(such as temp. shuffle blocks, cached RDD/broadcast blocks, spill files, etc) of worker directories following executor exits. Note that this doesn\u0027t overlap with `spark.worker.cleanup.enabled`, as this enables cleanup of non-shuffle files in local directories of a dead executor, while `spark.worker.cleanup.enabled` enables cleanup of all files/subdirectories of a stopped and timeout application. This only affects Standalone mode, support of other cluster managers can be added in the future.",
    "Since Version": "2.4.0"
  },
  {
    "Property Name": "spark.worker.ui.compressedLogFileLengthCacheSize",
    "Default": "100",
    "Meaning": "For compressed log files, the uncompressed file can only be computed by uncompressing the files. Spark caches the uncompressed file size of compressed log files. This property controls the cache size.",
    "Since Version": "2.0.2"
  },
  {
    "Property Name": "spark.standalone.submit.waitAppCompletion",
    "Meaning": "In standalone cluster mode, controls whether the client waits to exit until the application completes. If set to true, the client process will stay alive polling the driver\u0027s status. Otherwise, the client process will exit after submission.",
    "Since Version": "3.1.0",
    "Default": "false"
  },
  {
    "Meaning": "Set to FILESYSTEM to enable single-node recovery mode (default: NONE).",
    "Since Version": "0.8.1",
    "Property Name": "spark.deploy.recoveryMode"
  },
  {
    "Meaning": "The directory in which Spark will store recovery state, accessible from the Master\u0027s perspective.",
    "Since Version": "0.8.1",
    "Property Name": "spark.deploy.recoveryDirectory"
  }
]
